{"version":3,"file":"download.cjs","names":["appendURL","handleRequestErrs","getInfo"],"sources":["../src/download.ts"],"sourcesContent":["/** @internal @packageDocumentation */\n\nimport type { AxiosInstance } from 'axios'\nimport m3u8stream from 'm3u8stream'\nimport { handleRequestErrs, appendURL } from './util'\nimport getInfo, { type Transcoding } from './info'\n\nexport const getMediaURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<string> => {\n  const res = await axiosInstance.get(appendURL(url, 'client_id', clientID), {\n    headers: {\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.52 Safari/537.36',\n      Accept: '*/*',\n      'Accept-Encoding': 'gzip, deflate, br'\n    },\n    withCredentials: true\n  })\n  if (!res.data.url) throw new Error(`Invalid response from Soundcloud. Check if the URL provided is correct: ${url}`)\n  return res.data.url\n}\n\nexport const getProgressiveStream = async (mediaUrl: string, axiosInstance: AxiosInstance) => {\n  const r = await axiosInstance.get(mediaUrl, {\n    withCredentials: true,\n    responseType: 'stream'\n  })\n\n  return r.data\n}\n\nexport const getHLSStream = (mediaUrl: string) => m3u8stream(mediaUrl)\n\n/** @internal */\ntype fromURLFunctionBase = (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance) => Promise<any | m3u8stream.Stream>\n\nexport const fromURLBase: fromURLFunctionBase = async (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\n  try {\n    const mediaUrl = await getMediaURLFunction(url, clientID, axiosInstance)\n\n    if (url.includes('/progressive')) {\n      return await getProgressiveStreamFunction(mediaUrl, axiosInstance)\n    }\n\n    return getHLSStreamFunction(mediaUrl)\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\nexport const fromURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => await fromURLBase(url, clientID, getMediaURL, getProgressiveStream, getHLSStream, axiosInstance)\n\nexport const fromMediaObjBase = async (media: Transcoding, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  fromURLFunction: typeof fromURL,\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\n  if (!validateMedia(media)) throw new Error('Invalid media object provided')\n  return await fromURLFunction(media.url, clientID, axiosInstance)\n}\n\nexport const fromMediaObj = async (media: Transcoding, clientID: string, axiosInstance: AxiosInstance) => await fromMediaObjBase(media, clientID, getMediaURL, getProgressiveStream, getHLSStream, fromURL, axiosInstance)\n\nexport const fromDownloadLink = async (id: number, clientID: string, axiosInstance: AxiosInstance) => {\n  const { data: { redirectUri } } = await axiosInstance.get(appendURL(`https://api-v2.soundcloud.com/tracks/${id}/download`, 'client_id', clientID))\n  const { data } = await axiosInstance.get(redirectUri, {\n    responseType: 'stream'\n  })\n\n  return data\n}\n\n/**\n * Waliduje czy media transcoding jest prawidłowy\n * @internal\n */\nconst validateMedia = (media: Transcoding): boolean => {\n  if (!media || !media.url || !media.format) return false\n  if (!media.format.protocol) return false\n  // Sprawdź czy protocol jest obsługiwany\n  if (!['hls', 'progressive'].includes(media.format.protocol)) return false\n  return true\n}\n\n/** @internal */\nexport const download = async (url: string, clientID: string, axiosInstance: AxiosInstance, useDownloadLink = true) => {\n  const info = await getInfo(url, clientID, axiosInstance)\n\n  if (info.downloadable && useDownloadLink) {\n    try {\n      return await fromDownloadLink(info.id, clientID, axiosInstance)\n    } catch (err) {\n      console.log('Download link failed, trying transcoding...')\n    }\n  }\n\n  // Ulepszone wybieranie najlepszego transcoding\n  const availableTranscodings = info.media.transcodings.filter((t: Transcoding) =>\n    validateMedia(t) &&\n    t.url &&\n    t.format &&\n    (t.format.protocol === 'hls' || t.format.protocol === 'progressive')\n  )\n\n  if (availableTranscodings.length === 0) {\n    throw new Error('No valid transcoding available for this track')\n  }\n\n  // Preferuj progressive nad HLS (lepiej działa z Discord)\n  const preferredTranscoding = availableTranscodings.find((t: Transcoding) =>\n    t.format.protocol === 'progressive'\n  ) || availableTranscodings[0]\n\n  // Spróbuj wszystkich dostępnych transcodings jeśli pierwszy nie działa\n  for (let i = 0; i < availableTranscodings.length; i++) {\n    const transcoding = availableTranscodings[i]\n    try {\n      return await fromMediaObj(transcoding, clientID, axiosInstance)\n    } catch (err) {\n      console.log(`Transcoding failed: ${transcoding.format.protocol}, trying next...`)\n      if (i === availableTranscodings.length - 1) {\n        throw err // Ostatni transcoding - rzuć błąd\n      }\n    }\n  }\n}\n"],"mappings":"2mBAOA,MAAa,EAAc,MAAO,EAAa,EAAkB,IAAkD,CACjH,IAAM,EAAM,MAAM,EAAc,IAAIA,EAAAA,EAAU,EAAK,YAAa,EAAS,CAAE,CACzE,QAAS,CACP,aAAc,4HACd,OAAQ,MACR,kBAAmB,oBACpB,CACD,gBAAiB,GAClB,CAAC,CACF,GAAI,CAAC,EAAI,KAAK,IAAK,MAAU,MAAM,2EAA2E,IAAM,CACpH,OAAO,EAAI,KAAK,KAGL,EAAuB,MAAO,EAAkB,KACjD,MAAM,EAAc,IAAI,EAAU,CAC1C,gBAAiB,GACjB,aAAc,SACf,CAAC,EAEO,KAGE,EAAgB,IAAA,EAAA,EAAA,SAAgC,EAAS,CASzD,EAAmC,MAAO,EAAa,EAClE,EACA,EACA,EACA,IAAmE,CACnE,GAAI,CACF,IAAM,EAAW,MAAM,EAAoB,EAAK,EAAU,EAAc,CAMxE,OAJI,EAAI,SAAS,eAAe,CACvB,MAAM,EAA6B,EAAU,EAAc,CAG7D,EAAqB,EAAS,OAC9B,EAAK,CACZ,MAAMC,EAAAA,EAAkB,EAAI,GAInB,EAAU,MAAO,EAAa,EAAkB,IAAmE,MAAM,EAAY,EAAK,EAAU,EAAa,EAAsB,EAAc,EAAc,CAEnN,EAAmB,MAAO,EAAoB,EACzD,EACA,EACA,EACA,EACA,IAAmE,CACnE,GAAI,CAAC,EAAc,EAAM,CAAE,MAAU,MAAM,gCAAgC,CAC3E,OAAO,MAAM,EAAgB,EAAM,IAAK,EAAU,EAAc,EAGrD,EAAe,MAAO,EAAoB,EAAkB,IAAiC,MAAM,EAAiB,EAAO,EAAU,EAAa,EAAsB,EAAc,EAAS,EAAc,CAE7M,EAAmB,MAAO,EAAY,EAAkB,IAAiC,CACpG,GAAM,CAAE,KAAM,CAAE,gBAAkB,MAAM,EAAc,IAAID,EAAAA,EAAU,wCAAwC,EAAG,WAAY,YAAa,EAAS,CAAC,CAC5I,CAAE,QAAS,MAAM,EAAc,IAAI,EAAa,CACpD,aAAc,SACf,CAAC,CAEF,OAAO,GAOH,EAAiB,GAIrB,EAHI,CAAC,GAAS,CAAC,EAAM,KAAO,CAAC,EAAM,QAC/B,CAAC,EAAM,OAAO,UAEd,CAAC,CAAC,MAAO,cAAc,CAAC,SAAS,EAAM,OAAO,SAAS,EAKhD,EAAW,MAAO,EAAa,EAAkB,EAA8B,EAAkB,KAAS,CACrH,IAAM,EAAO,MAAME,EAAAA,EAAQ,EAAK,EAAU,EAAc,CAExD,GAAI,EAAK,cAAgB,EACvB,GAAI,CACF,OAAO,MAAM,EAAiB,EAAK,GAAI,EAAU,EAAc,MACnD,CACZ,QAAQ,IAAI,8CAA8C,CAK9D,IAAM,EAAwB,EAAK,MAAM,aAAa,OAAQ,GAC5D,EAAc,EAAE,EAChB,EAAE,KACF,EAAE,SACD,EAAE,OAAO,WAAa,OAAS,EAAE,OAAO,WAAa,eACvD,CAED,GAAI,EAAsB,SAAW,EACnC,MAAU,MAAM,gDAAgD,CAIrC,EAAsB,KAAM,GACvD,EAAE,OAAO,WAAa,cACvB,EAAI,EAAsB,GAG3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAsB,OAAQ,IAAK,CACrD,IAAM,EAAc,EAAsB,GAC1C,GAAI,CACF,OAAO,MAAM,EAAa,EAAa,EAAU,EAAc,OACxD,EAAK,CAEZ,GADA,QAAQ,IAAI,uBAAuB,EAAY,OAAO,SAAS,kBAAkB,CAC7E,IAAM,EAAsB,OAAS,EACvC,MAAM"}