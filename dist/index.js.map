{"version":3,"file":"index.js","names":["descriptiveMessage: string","URL","batches: number[][]","sorted: TrackInfo[]","data: TrackInfo","fromURLBase: fromURLFunctionBase","getInfo","response!: PaginatedQuery<Like>","nextHref: string | undefined","filterMedia","getInfo","retryConfig: RetryConfig","id: number","isValidURL","c: ClientIDData","err"],"sources":["../src/util.ts","../src/protocols.ts","../src/formats.ts","../src/info.ts","../src/filter-media.ts","../src/download.ts","../src/url.ts","../src/search.ts","../src/download-playlist.ts","../src/likes.ts","../src/user.ts","../src/index.ts"],"sourcesContent":["/** @internal @packageDocumentation */\r\nimport { URL } from 'url'\r\nimport { isAxiosError, type AxiosError } from 'axios'\r\n/* eslint-disable camelcase */\r\nexport interface PaginatedQuery<T> {\r\n  collection: T[],\r\n  total_results?: number, // is omitted if limit parameter is supplied\r\n  next_href: string,\r\n  query_urn: string\r\n}\r\nexport const resolveURL = 'https://api-v2.soundcloud.com/resolve'\r\nexport const handleRequestErrs = (err: unknown): Error => {\r\n  // Obsługa błędów nie-Axios\r\n  if (!isAxiosError(err)) {\r\n    if (err instanceof Error) {\r\n      return err;\r\n    }\r\n    return new Error('Unknown error occurred', { cause: err });\r\n  }\r\n  const axiosErr = err as AxiosError;\r\n\r\n  // Brak odpowiedzi - problemy sieciowe\r\n  if (!axiosErr.response) {\r\n    // Obsługa obu kodów timeout: ECONNABORTED i ETIMEDOUT\r\n    const code = axiosErr.code;\r\n    const message = code === 'ECONNABORTED' || code === 'ETIMEDOUT'\r\n      ? 'Request timeout. Please check your connection.'\r\n      : code === 'ERR_NETWORK'\r\n        ? 'Network error. Please check your internet connection.'\r\n        : code === 'ERR_CANCELED'\r\n          ? 'Request was canceled.'\r\n          : 'Request failed. Please try again.';\r\n    return new Error(message, { cause: axiosErr });\r\n  }\r\n  const status = axiosErr.response.status;\r\n  let descriptiveMessage: string;\r\n  switch (status) {\r\n    case 400:\r\n      descriptiveMessage = 'Bad request. Please check the parameters.';\r\n      break;\r\n    case 401:\r\n      descriptiveMessage = 'Authentication failed. Is your Client ID correct?';\r\n      break;\r\n    case 403:\r\n      descriptiveMessage = 'Access forbidden. You may not have permission to access this resource.';\r\n      break;\r\n    case 404:\r\n      descriptiveMessage = 'Resource not found. It may be private or the URL is incorrect.';\r\n      break;\r\n    case 429:\r\n      descriptiveMessage = 'Rate limit exceeded. Please wait before making more requests.';\r\n      break;\r\n    case 500:\r\n    case 502:\r\n    case 503:\r\n    case 504:\r\n      descriptiveMessage = 'SoundCloud server error. Please try again later.';\r\n      break;\r\n    default:\r\n      descriptiveMessage = `Request failed with status ${status}: ${axiosErr.message}`;\r\n  }\r\n  return new Error(descriptiveMessage, { cause: axiosErr });\r\n}\r\nexport const appendURL = (url: string, ...params: string[]): string => {\r\n  try {\r\n    const u = new URL(url);\r\n\r\n    // Walidacja: params musi być parzystej długości\r\n    if (params.length % 2 !== 0) {\r\n      throw new Error(\r\n        `Parameters must be provided in key-value pairs. Received ${params.length} parameters.`\r\n      );\r\n    }\r\n    for (let idx = 0; idx < params.length; idx += 2) {\r\n      const key = params[idx];\r\n      const value = params[idx + 1];\r\n\r\n      if (key && value !== undefined && value !== null) {\r\n        u.searchParams.append(key, value);\r\n      }\r\n    }\r\n\r\n    return u.href;\r\n  } catch (err) {\r\n    if (err instanceof TypeError) {\r\n      throw new Error(`Invalid URL: ${url}`, { cause: err });\r\n    }\r\n    throw err;\r\n  }\r\n}\r\nexport const extractIDFromPersonalizedTrackURL = (url: string): string => {\r\n  if (!url || typeof url !== 'string') return '';\r\n  if (!url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) return '';\r\n\r\n  const colonIndex = url.lastIndexOf(':');\r\n  if (colonIndex === -1) return '';\r\n\r\n  return url.slice(colonIndex + 1);\r\n}\r\nexport const kindMismatchError = (expected: string, received: string): Error =>\r\n  new Error(`Expected resource of kind: (${expected}), received: (${received})`);\r\n","/**\r\n * Soundcloud streams tracks using these protocols.\r\n */\r\nenum STREAMING_PROTOCOLS {\r\n  HLS = 'hls',\r\n  PROGRESSIVE = 'progressive'\r\n}\r\n\r\n/** @internal */\r\nexport const _PROTOCOLS = {\r\n  HLS: STREAMING_PROTOCOLS.HLS,\r\n  PROGRESSIVE: STREAMING_PROTOCOLS.PROGRESSIVE\r\n}\r\n\r\nexport default STREAMING_PROTOCOLS\r\n","/**\r\n * Audio formats a track can be encoded in.\r\n */\r\nexport enum FORMATS {\r\n  MP3 = 'audio/mpeg',\r\n  OPUS = 'audio/ogg; codecs=\"opus\"',\r\n  AAC = 'audio/aac',\r\n  AAC_LC = 'audio/aac-lc',         // Low Complexity AAC\r\n  FLAC = 'audio/flac',\r\n  WAV = 'audio/wav',\r\n  WEBM_OPUS = 'audio/webm; codecs=\"opus\"', // WebM container z Opus\r\n  OGG_VORBIS = 'audio/ogg; codecs=\"vorbis\"', // OGG z Vorbis\r\n  ALAC = 'audio/alac',               // Apple Lossless\r\n  AIFF = 'audio/aiff',               // AIFF PCM\r\n  M4A = 'audio/mp4; codecs=\"mp4a.40.2\"' // AAC w kontenerze M4A\r\n}\r\n\r\n/** @internal */\r\nexport const _FORMATS = {\r\n  MP3: FORMATS.MP3,\r\n  OPUS: FORMATS.OPUS,\r\n  AAC: FORMATS.AAC,\r\n  AAC_LC: FORMATS.AAC_LC,\r\n  FLAC: FORMATS.FLAC,\r\n  WAV: FORMATS.WAV,\r\n  WEBM_OPUS: FORMATS.WEBM_OPUS,\r\n  OGG_VORBIS: FORMATS.OGG_VORBIS,\r\n  ALAC: FORMATS.ALAC,\r\n  AIFF: FORMATS.AIFF,\r\n  M4A: FORMATS.M4A\r\n};\r\n\r\nexport default FORMATS;\r\n","/* eslint-disable camelcase */\r\nimport type { AxiosInstance } from 'axios'\r\nimport { handleRequestErrs, appendURL, extractIDFromPersonalizedTrackURL } from './util'\r\nimport STREAMING_PROTOCOLS from './protocols'\r\nimport FORMATS from './formats'\r\n\r\n/**\r\n * A Soundcloud user\r\n */\r\nexport interface User {\r\n  kind: string,\r\n  avatar_url: string,\r\n  city: string,\r\n  comments_count: number,\r\n  country_code: string,\r\n  created_at: string,\r\n  description: string,\r\n  followers_count: number,\r\n  followings_count: number,\r\n  first_name: string,\r\n  full_name: string,\r\n  groups_count: number,\r\n  id: number,\r\n  last_name: string,\r\n  permalink_url: string,\r\n  uri: string,\r\n  username: string\r\n}\r\n\r\n/**\r\n * Details about the track\r\n */\r\nexport interface TrackInfo {\r\n  kind: string\r\n  monetization_model: string,\r\n  id: number,\r\n  policy: string,\r\n  comment_count?: number,\r\n  full_duration?: number,\r\n  downloadable?: false,\r\n  created_at?: string,\r\n  description?: string,\r\n  media?: { transcodings: Transcoding[] },\r\n  title?: string,\r\n  publisher_metadata?: any,\r\n  duration?: number,\r\n  has_downloads_left?: boolean,\r\n  artwork_url?: string,\r\n  public?: boolean,\r\n  streamable?: true,\r\n  tag_list?: string,\r\n  genre?: string,\r\n  reposts_count?: number,\r\n  label_name?: string,\r\n  state?: string,\r\n  last_modified?: string,\r\n  commentable?: boolean,\r\n  uri?: string,\r\n  download_count?: number,\r\n  likes_count?: number,\r\n  display_date?: string,\r\n  user_id?: number,\r\n  waveform_url?: string,\r\n  permalink?: string,\r\n  permalink_url?: string,\r\n  user?: User,\r\n  playback_count?: number\r\n}\r\n\r\n/**\r\n * Details about a Set\r\n */\r\nexport interface SetInfo {\r\n  duration: number,\r\n  permalink_url: string,\r\n  reposts_count: number,\r\n  genre: string,\r\n  permalink: string,\r\n  purchase_url?: string,\r\n  description?: string,\r\n  uri: string,\r\n  label_name?: string,\r\n  tag_list: string,\r\n  set_type: string,\r\n  public: boolean,\r\n  track_count: number,\r\n  user_id: number,\r\n  last_modified: string,\r\n  license: string,\r\n  tracks: TrackInfo[],\r\n  id: number,\r\n  release_date?: string,\r\n  display_date: string,\r\n  sharing: string,\r\n  secret_token?: string,\r\n  created_at: string,\r\n  likes_count: number,\r\n  kind: string,\r\n  purchase_title?: string,\r\n  managed_by_feeds: boolean,\r\n  artwork_url?: string,\r\n  is_album: boolean,\r\n  user: User,\r\n  published_at: string,\r\n  embeddable_by: string\r\n}\r\n\r\n/**\r\n * Represents an audio link to a Soundcloud Track\r\n */\r\nexport interface Transcoding {\r\n  url: string,\r\n  preset: string,\r\n  snipped: boolean,\r\n  format: { protocol: STREAMING_PROTOCOLS, mime_type: FORMATS }\r\n}\r\n\r\nconst getTrackInfoBase = async (clientID: string, axiosRef: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string): Promise<TrackInfo[]> => {\r\n  let url = appendURL('https://api-v2.soundcloud.com/tracks', 'ids', ids.join(','), 'client_id', clientID)\r\n  if (playlistID && playlistSecretToken) {\r\n    url = appendURL(url, 'playlistId', String(playlistID), 'playlistSecretToken', playlistSecretToken)\r\n  }\r\n  try {\r\n    const { data } = await axiosRef.get(url)\r\n\r\n    return data as TrackInfo[]\r\n  } catch (err) {\r\n    throw handleRequestErrs(err)\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport const getInfoBase = async <T extends TrackInfo | SetInfo>(url: string, clientID: string, axiosRef: AxiosInstance): Promise<T> => {\r\n  try {\r\n    const res = await axiosRef.get(appendURL('https://api-v2.soundcloud.com/resolve', 'url', url, 'client_id', clientID), {\r\n      withCredentials: true\r\n    })\r\n\r\n    return res.data as T\r\n  } catch (err) {\r\n    throw handleRequestErrs(err)\r\n  }\r\n}\r\n\r\n/** @internal */\r\nconst getSetInfoBase = async (url: string, clientID: string, axiosRef: AxiosInstance): Promise<SetInfo> => {\r\n  const setInfo = await getInfoBase<SetInfo>(url, clientID, axiosRef)\r\n  const originalOrder = setInfo.tracks.map(track => track.id)\r\n  const playlistID = setInfo.id\r\n  const playlistSecretToken = setInfo.secret_token\r\n  const incompleteTracks = setInfo.tracks.filter(track => !track.title)\r\n\r\n  if (incompleteTracks.length === 0) {\r\n    return setInfo\r\n  }\r\n\r\n  const completeTracks = setInfo.tracks.filter(track => track.title)\r\n  const incompleteIds = incompleteTracks.map(t => t.id)\r\n\r\n  if (incompleteIds.length > 50) {\r\n    const batchSize = 50\r\n    const batches: number[][] = []\r\n\r\n    for (let i = 0; i < incompleteIds.length; i += batchSize) {\r\n      batches.push(incompleteIds.slice(i, i + batchSize))\r\n    }\r\n\r\n    const promises = batches.map(ids => getTrackInfoByID(clientID, axiosRef, ids, playlistID, playlistSecretToken))\r\n    const fetchedTracks = await Promise.all(promises)\r\n    setInfo.tracks = completeTracks.concat(...fetchedTracks)\r\n  } else {\r\n    const fetchedTracks = await getTrackInfoByID(clientID, axiosRef, incompleteIds, playlistID, playlistSecretToken)\r\n    setInfo.tracks = completeTracks.concat(fetchedTracks)\r\n  }\r\n\r\n  setInfo.tracks = sortTracks(setInfo.tracks, originalOrder)\r\n  return setInfo\r\n}\r\n\r\n/** @internal */\r\nconst sortTracks = (tracks: TrackInfo[], ids: number[]): TrackInfo[] => {\r\n  const trackMap = new Map<number, TrackInfo>()\r\n\r\n  for (const track of tracks) {\r\n    trackMap.set(track.id, track)\r\n  }\r\n\r\n  const sorted: TrackInfo[] = []\r\n  for (const id of ids) {\r\n    const track = trackMap.get(id)\r\n    if (track) {\r\n      sorted.push(track)\r\n    }\r\n  }\r\n\r\n  return sorted\r\n}\r\n\r\n/** @internal */\r\nconst getInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<TrackInfo> => {\r\n  let data: TrackInfo\r\n\r\n  if (url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) {\r\n    const idString = extractIDFromPersonalizedTrackURL(url)\r\n    if (!idString) throw new Error('Could not parse track ID from given URL: ' + url)\r\n\r\n    const id = parseInt(idString, 10)\r\n    if (isNaN(id)) {\r\n      throw new Error('Could not parse track ID from given URL: ' + url)\r\n    }\r\n\r\n    const tracks = await getTrackInfoByID(clientID, axiosInstance, [id])\r\n    const track = tracks[0]\r\n    if (!track) throw new Error('Could not find track with ID: ' + id)\r\n    data = track\r\n  } else {\r\n    data = await getInfoBase<TrackInfo>(url, clientID, axiosInstance)\r\n  }\r\n\r\n  if (!data.media) throw new Error('The given URL does not link to a Soundcloud track')\r\n  return data\r\n}\r\n\r\n/** @internal */\r\nexport const getSetInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<SetInfo> => {\r\n  const data = await getSetInfoBase(url, clientID, axiosInstance)\r\n  if (!data.tracks) throw new Error('The given URL does not link to a Soundcloud set')\r\n  return data\r\n}\r\n\r\n/** @internal */\r\nexport const getTrackInfoByID = async (clientID: string, axiosInstance: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string) => {\r\n  return await getTrackInfoBase(clientID, axiosInstance, ids, playlistID, playlistSecretToken)\r\n}\r\nexport default getInfo\r\n","import type { Transcoding } from './info'\r\nimport FORMATS from './formats'\r\nimport STREAMING_PROTOCOLS from './protocols'\r\n\r\nexport interface FilterPredicateObject {\r\n  protocol?: STREAMING_PROTOCOLS\r\n  format?: FORMATS\r\n}\r\n\r\n/** @internal */\r\nconst filterMedia = (\r\n  media: Transcoding[],\r\n  predicate: FilterPredicateObject\r\n): Transcoding[] => {\r\n  return media.filter(({ format, snipped }) => {\r\n    // Odrzuć snippety\r\n    if (snipped) {\r\n      return false\r\n    }\r\n    \r\n    // Sprawdź protokół jeśli podany\r\n    if (predicate.protocol !== undefined && format.protocol !== predicate.protocol) {\r\n      return false\r\n    }\r\n    \r\n    // Sprawdź format jeśli podany\r\n    if (predicate.format !== undefined && format.mime_type !== predicate.format) {\r\n      return false\r\n    }\r\n    \r\n    return true\r\n  })\r\n}\r\n\r\nexport default filterMedia\r\n","/** @internal @packageDocumentation */\r\n\r\nimport type { AxiosInstance } from 'axios'\r\nimport m3u8stream from 'm3u8stream'\r\nimport { handleRequestErrs, appendURL } from './util'\r\nimport getInfo, { type Transcoding } from './info'\r\n\r\nexport const getMediaURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<string> => {\r\n  const res = await axiosInstance.get(appendURL(url, 'client_id', clientID), {\r\n    headers: {\r\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.52 Safari/537.36',\r\n      Accept: '*/*',\r\n      'Accept-Encoding': 'gzip, deflate, br'\r\n    },\r\n    withCredentials: true\r\n  })\r\n  if (!res.data.url) throw new Error(`Invalid response from Soundcloud. Check if the URL provided is correct: ${url}`)\r\n  return res.data.url\r\n}\r\n\r\nexport const getProgressiveStream = async (mediaUrl: string, axiosInstance: AxiosInstance) => {\r\n  const r = await axiosInstance.get(mediaUrl, {\r\n    withCredentials: true,\r\n    responseType: 'stream'\r\n  })\r\n\r\n  return r.data\r\n}\r\n\r\nexport const getHLSStream = (mediaUrl: string) => m3u8stream(mediaUrl)\r\n\r\n/** @internal */\r\ntype fromURLFunctionBase = (url: string, clientID: string,\r\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\r\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\r\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\r\n  axiosInstance: AxiosInstance) => Promise<any | m3u8stream.Stream>\r\n\r\nexport const fromURLBase: fromURLFunctionBase = async (url: string, clientID: string,\r\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\r\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\r\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\r\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\r\n  try {\r\n    const mediaUrl = await getMediaURLFunction(url, clientID, axiosInstance)\r\n\r\n    if (url.includes('/progressive')) {\r\n      return await getProgressiveStreamFunction(mediaUrl, axiosInstance)\r\n    }\r\n\r\n    return getHLSStreamFunction(mediaUrl)\r\n  } catch (err) {\r\n    throw handleRequestErrs(err)\r\n  }\r\n}\r\n\r\nexport const fromURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => await fromURLBase(url, clientID, getMediaURL, getProgressiveStream, getHLSStream, axiosInstance)\r\n\r\nexport const fromMediaObjBase = async (media: Transcoding, clientID: string,\r\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\r\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\r\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\r\n  fromURLFunction: typeof fromURL,\r\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\r\n  if (!validateMedia(media)) throw new Error('Invalid media object provided')\r\n  return await fromURLFunction(media.url, clientID, axiosInstance)\r\n}\r\n\r\nexport const fromMediaObj = async (media: Transcoding, clientID: string, axiosInstance: AxiosInstance) => await fromMediaObjBase(media, clientID, getMediaURL, getProgressiveStream, getHLSStream, fromURL, axiosInstance)\r\n\r\nexport const fromDownloadLink = async (id: number, clientID: string, axiosInstance: AxiosInstance) => {\r\n  const { data: { redirectUri } } = await axiosInstance.get(appendURL(`https://api-v2.soundcloud.com/tracks/${id}/download`, 'client_id', clientID))\r\n  const { data } = await axiosInstance.get(redirectUri, {\r\n    responseType: 'stream'\r\n  })\r\n\r\n  return data\r\n}\r\n\r\n/**\r\n * Waliduje czy media transcoding jest prawidłowy\r\n * @internal\r\n */\r\nconst validateMedia = (media: Transcoding): boolean => {\r\n  if (!media || !media.url || !media.format) return false\r\n  if (!media.format.protocol) return false\r\n  // Sprawdź czy protocol jest obsługiwany\r\n  if (!['hls', 'progressive'].includes(media.format.protocol)) return false\r\n  return true\r\n}\r\n\r\n/** @internal */\r\nexport const download = async (url: string, clientID: string, axiosInstance: AxiosInstance, useDownloadLink = true) => {\r\n  const info = await getInfo(url, clientID, axiosInstance)\r\n\r\n  if (info.downloadable && useDownloadLink) {\r\n    try {\r\n      return await fromDownloadLink(info.id, clientID, axiosInstance)\r\n    } catch (err) {\r\n      console.log('Download link failed, trying transcoding...')\r\n    }\r\n  }\r\n\r\n  // Ulepszone wybieranie najlepszego transcoding\r\n  const availableTranscodings = info.media.transcodings.filter(t =>\r\n    validateMedia(t) &&\r\n    t.url &&\r\n    t.format &&\r\n    (t.format.protocol === 'hls' || t.format.protocol === 'progressive')\r\n  )\r\n\r\n  if (availableTranscodings.length === 0) {\r\n    throw new Error('No valid transcoding available for this track')\r\n  }\r\n\r\n  // Preferuj progressive nad HLS (lepiej działa z Discord)\r\n  const preferredTranscoding = availableTranscodings.find(t =>\r\n    t.format.protocol === 'progressive'\r\n  ) || availableTranscodings[0]\r\n\r\n  // Spróbuj wszystkich dostępnych transcodings jeśli pierwszy nie działa\r\n  for (let i = 0; i < availableTranscodings.length; i++) {\r\n    const transcoding = availableTranscodings[i]\r\n    try {\r\n      return await fromMediaObj(transcoding, clientID, axiosInstance)\r\n    } catch (err) {\r\n      console.log(`Transcoding failed: ${transcoding.format.protocol}, trying next...`)\r\n      if (i === availableTranscodings.length - 1) {\r\n        throw err // Ostatni transcoding - rzuć błąd\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { AxiosInstance } from 'axios';\r\n\r\n/**\r\n * Regex dopasowujący standardowe i mobilne adresy URL SoundCloud.\r\n * Obsługuje:\r\n * - http://soundcloud.com/...\r\n * - https://soundcloud.com/...\r\n * - http://m.soundcloud.com/...\r\n * - https://m.soundcloud.com/...\r\n */\r\nconst SOUNDCLOUD_URL_REGEX = /^https?:\\/\\/(m\\.)?soundcloud\\.com\\/.+/;\r\n\r\n/**\r\n * Regex dopasowujący adresy URL skracacza linków Firebase używanego przez SoundCloud.\r\n */\r\n/**\r\n * Regex dopasowujący adresy URL skracaczy linków używanych przez SoundCloud (Firebase i on.soundcloud).\r\n * Obsługuje np:\r\n * - https://soundcloud.app.goo.gl/...\r\n * - https://on.soundcloud.com/...\r\n */\r\nconst FIREBASE_URL_REGEX = /^https?:\\/\\/(?:soundcloud\\.app\\.goo\\.gl|on\\.soundcloud\\.com)\\/.+/;\r\n\r\n/**\r\n * Ogólny regex do wyszukiwania (scrapowania) dowolnego adresu URL w tekście.\r\n * Używany do znalezienia docelowego linku SoundCloud w odpowiedzi z linku Firebase.\r\n */\r\nconst GENERIC_URL_SCRAPE_REGEX = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,500}\\.[a-zA-Z0-9()]{1,500}\\b([-a-zA-Z0-9()@:%_+.~#?&/\\\\=;]*)/g;\r\n\r\n/**\r\n * Stały prefix do sprawdzania spersonalizowanych URL\r\n */\r\nconst PERSONALIZED_TRACK_PREFIX = 'https://soundcloud.com/discover/sets/personalized-tracks::';\r\n\r\n// --- Funkcje pomocnicze ---\r\n\r\n/**\r\n * Sprawdza, czy podany ciąg znaków jest prawidłowym adresem URL SoundCloud (standardowym, mobilnym lub Firebase).\r\n * @param url - Adres URL do przetestowania.\r\n * @param testFirebase - Czy uwzględnić sprawdzanie linków Firebase (domyślnie true).\r\n * @returns `true`, jeśli adres URL jest prawidłowy, w przeciwnym razie `false`.\r\n */\r\nexport const isURL = (url: string, testFirebase: boolean = true, stripMobilePrefix?: boolean): boolean => {\r\n  if (typeof url !== 'string') return false;\r\n  // Sprawdza, czy pasuje do standardowego/mobilnego URL-a LUB (jeśli włączone) do URL-a Firebase.\r\n  return SOUNDCLOUD_URL_REGEX.test(url) || (testFirebase && FIREBASE_URL_REGEX.test(url));\r\n};\r\n\r\n/**\r\n * Sprawdza, czy URL prowadzi do playlisty (setu) na SoundCloud.\r\n * @param url - Adres URL do sprawdzenia.\r\n * @returns `true`, jeśli URL jest playlistą, w przeciwnym razie `false`.\r\n */\r\nexport const isPlaylistURL = (url: string): boolean => {\r\n  // `isURL` sprawdza teraz również format linku Firebase, więc testFirebase ustawiamy na false,\r\n  // aby upewnić się, że analizujemy już rozwiązany URL SoundCloud.\r\n  if (!isURL(url, false)) {\r\n    return false;\r\n  }\r\n\r\n  // Szybkie sprawdzenie string przed parsowaniem URL\r\n  if (!url.includes('/sets/')) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const parsedUrl = new URL(url);\r\n    // Dodatkowe, bardziej rygorystyczne sprawdzenie ścieżki\r\n    return parsedUrl.pathname.includes('/sets/');\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Sprawdza, czy URL jest linkiem do spersonalizowanej playlisty \"Odkrywaj\" na SoundCloud.\r\n * @param url - Adres URL do sprawdzenia.\r\n * @returns `true`, jeśli URL jest spersonalizowaną playlistą, w przeciwnym razie `false`.\r\n */\r\nexport const isPersonalizedTrackURL = (url: string): boolean => {\r\n  if (typeof url !== 'string') return false;\r\n  return url.startsWith(PERSONALIZED_TRACK_PREFIX);\r\n};\r\n\r\n/**\r\n * Usuwa prefiks mobilny 'm.' z adresu URL SoundCloud.\r\n * @param url - Adres URL do przetworzenia.\r\n * @returns Adres URL bez prefiksu mobilnego lub oryginalny URL, jeśli nie był to link mobilny.\r\n */\r\nexport const stripMobilePrefix = (url: string): string => {\r\n  try {\r\n    const urlObject = new URL(url);\r\n    if (urlObject.hostname === 'm.soundcloud.com') {\r\n      urlObject.hostname = 'soundcloud.com';\r\n      return urlObject.toString();\r\n    }\r\n    return url;\r\n  } catch {\r\n    // Zwraca oryginalny URL w przypadku błędu parsowania (np. nieprawidłowy URL)\r\n    return url;\r\n  }\r\n};\r\n\r\n/**\r\n * Sprawdza, czy URL jest skróconym linkiem Firebase od SoundCloud.\r\n * @param url - Adres URL do sprawdzenia.\r\n * @returns `true`, jeśli to link Firebase, w przeciwnym razie `false`.\r\n */\r\n/**\r\n * Sprawdza, czy URL jest skróconym linkiem SoundCloud (np. Firebase shortener lub on.soundcloud.com).\r\n * @param url - Adres URL do sprawdzenia.\r\n * @returns `true`, jeśli to skrócony link SoundCloud, w przeciwnym razie `false`.\r\n */\r\nexport const isFirebaseURL = (url: string): boolean => {\r\n  if (typeof url !== 'string') return false;\r\n  return FIREBASE_URL_REGEX.test(url);\r\n};\r\n\r\n/**\r\n * Konwertuje skrócony link Firebase na pełny adres URL SoundCloud.\r\n * Pobiera zawartość strony z linku Firebase i wyszukuje w niej docelowy URL.\r\n * @param url - Skrócony URL Firebase (np. https://soundcloud.app.goo.gl/xyz).\r\n * @param axiosInstance - Instancja Axios do wykonania zapytania HTTP.\r\n * @returns Obietnica (Promise) rozwiązująca się do pełnego adresu URL SoundCloud lub `undefined`, jeśli nie można go znaleźć.\r\n * @throws Błąd, jeśli nie uda się znaleźć docelowego URL.\r\n */\r\nexport const convertFirebaseURL = async (url: string, axiosInstance: AxiosInstance): Promise<string | undefined> => {\r\n  const urlObject = new URL(url);\r\n  // Dodanie parametru 'd=1' może czasem pomóc w ominięciu przekierowań i uzyskaniu strony z metadanymi.\r\n  urlObject.searchParams.set('d', '1');\r\n\r\n  // Pobieramy zawartość HTML ze skróconego linku, ponieważ często zawiera on docelowy URL w tagach meta lub skryptach.\r\n  const { data: htmlContent } = await axiosInstance.get<string>(urlObject.toString());\r\n\r\n  // Reset lastIndex dla bezpieczeństwa (regex z flagą 'g' zachowuje stan)\r\n  GENERIC_URL_SCRAPE_REGEX.lastIndex = 0;\r\n  const allUrlsInHtml = htmlContent.match(GENERIC_URL_SCRAPE_REGEX);\r\n\r\n  if (!allUrlsInHtml || allUrlsInHtml.length === 0) {\r\n    throw new Error(`Could not find any URL in the response from the Firebase URL: ${url}`);\r\n  }\r\n\r\n  // Znajdź pierwszy URL, który jest prawidłowym linkiem do SoundCloud.\r\n  const soundcloudUrl = allUrlsInHtml.find(match => SOUNDCLOUD_URL_REGEX.test(match));\r\n\r\n  if (!soundcloudUrl) {\r\n    return undefined;\r\n  }\r\n\r\n  // Czasami URL w odpowiedzi jest zakodowany (np. \\u003d zamiast =).\r\n  // Ta operacja dekoduje znaki Unicode do ich standardowej postaci.\r\n  // Przykład: '.../tracks\\u003d123' -> '.../tracks=123'\r\n  return soundcloudUrl.replace(/\\\\u([\\d\\w]{4})/gi, (_match, grp) =>\r\n    String.fromCharCode(parseInt(grp, 16)),\r\n  );\r\n};\r\n\r\n// Eksport domyślny pozostaje bez zmian dla zgodności wstecznej.\r\nexport default isURL;\r\n","/* eslint-disable camelcase */\r\nimport type { AxiosInstance } from 'axios'\r\nimport type { TrackInfo, User, SetInfo } from './info'\r\nimport { appendURL, type PaginatedQuery } from './util'\r\n\r\nconst baseURL = 'https://api-v2.soundcloud.com/search'\r\n\r\nexport interface RelatedResponse<T> extends PaginatedQuery<T> {\r\n  variant: string\r\n}\r\n\r\nexport interface SearchOptions {\r\n  limit?: number,\r\n  offset?: number,\r\n  resourceType?: SoundcloudResource | 'all',\r\n  query?: string,\r\n  nextHref?: string,\r\n  q?: string\r\n}\r\n\r\nexport type SearchResponseAll = PaginatedQuery<User | SetInfo | TrackInfo>\r\nexport type SoundcloudResource = 'tracks' | 'users' | 'albums' | 'playlists'\r\n\r\nconst validResourceTypes = ['tracks', 'users', 'albums', 'playlists', 'all'] as const\r\n\r\n// Funkcja do normalizacji stringów (usuwa znaki specjalne, akcenty, małe litery)\r\nconst normalizeString = (str: string): string => {\r\n  return str\r\n    .toLowerCase()\r\n    .normalize('NFD')\r\n    .replace(/[\\u0300-\\u036f]/g, '') // usuń akcenty\r\n    .replace(/[^\\w\\s]/g, ' ') // zamień znaki specjalne na spacje\r\n    .replace(/\\s+/g, ' ') // zamień wielokrotne spacje na jedną\r\n    .trim()\r\n}\r\n\r\n// Funkcja do obliczania podobieństwa między tytułami\r\nconst calculateSimilarity = (query: string, title: string): number => {\r\n  const normalizedQuery = normalizeString(query)\r\n  const normalizedTitle = normalizeString(title)\r\n\r\n  // Jeśli tytuły są identyczne po normalizacji - maksymalny wynik\r\n  if (normalizedQuery === normalizedTitle) {\r\n    return 1000\r\n  }\r\n\r\n  // Sprawdź czy query jest dokładnie zawarte w tytule\r\n  if (normalizedTitle.includes(normalizedQuery)) {\r\n    return 800\r\n  }\r\n\r\n  // Sprawdź czy wszystkie słowa z query są w tytule\r\n  const queryWords = normalizedQuery.split(' ').filter(word => word.length > 0)\r\n  const titleWords = normalizedTitle.split(' ').filter(word => word.length > 0)\r\n\r\n  let matchingWords = 0\r\n  let exactMatches = 0\r\n\r\n  queryWords.forEach(queryWord => {\r\n    // Sprawdź dokładne dopasowanie\r\n    if (titleWords.some(titleWord => titleWord === queryWord)) {\r\n      exactMatches++\r\n      matchingWords++\r\n    }\r\n    // Sprawdź częściowe dopasowanie (słowo zawiera się w innym)\r\n    else if (titleWords.some(titleWord =>\r\n      titleWord.includes(queryWord) || queryWord.includes(titleWord)\r\n    )) {\r\n      matchingWords += 0.5\r\n    }\r\n  })\r\n\r\n  // Kara za dodatkowe słowa w tytule (preferuj krótsze, dokładniejsze tytuły)\r\n  const extraWords = Math.max(0, titleWords.length - queryWords.length)\r\n  const lengthPenalty = extraWords * 10\r\n\r\n  // Bonus za dokładne dopasowania\r\n  const exactMatchBonus = exactMatches * 100\r\n\r\n  // Bazowy wynik na podstawie % dopasowanych słów\r\n  const baseScore = (matchingWords / queryWords.length) * 500\r\n\r\n  return Math.max(0, baseScore + exactMatchBonus - lengthPenalty)\r\n}\r\n\r\n// Funkcja do sprawdzania czy to remix/cover/live version\r\nconst isOriginalVersion = (title: string, query: string): boolean => {\r\n  const normalizedTitle = normalizeString(title)\r\n\r\n  const modifierKeywords = [\r\n    'remix', 'cover', 'live', 'acoustic', 'instrumental', 'karaoke',\r\n    'extended', 'radio edit', 'club mix', 'dub', 'version', 'edit',\r\n    'remaster', 'rework', 'bootleg', 'mashup', 'flip'\r\n  ]\r\n\r\n  // Sprawdź czy tytuł zawiera słowa wskazujące na modyfikację\r\n  const hasModifiers = modifierKeywords.some(keyword =>\r\n    normalizedTitle.includes(keyword)\r\n  )\r\n\r\n  // Sprawdź czy query zawiera te słowa (jeśli tak, to użytkownik ich szuka)\r\n  const queryWantsModified = modifierKeywords.some(keyword =>\r\n    normalizeString(query).includes(keyword)\r\n  )\r\n\r\n  // Jeśli query nie zawiera modyfikatorów, ale tytuł tak - to prawdopodobnie nie oryginał\r\n  return !hasModifiers || queryWantsModified\r\n}\r\n\r\n/**\r\n * Waliduje czy track jest dostępny do streamowania\r\n * @internal\r\n */\r\nconst isTrackValid = (track: any): boolean => {\r\n  // Podstawowe sprawdzenia\r\n  if (!track || typeof track !== 'object') return false\r\n  if (!track.permalink_url || !track.title) return false\r\n\r\n  // Odrzucaj sample o długości w pobliżu 30s (29.5–30.5 sekundy)\r\n  if (\r\n    typeof track.duration === 'number' &&\r\n    track.duration >= 29500 &&\r\n    track.duration <= 30500\r\n  ) return false\r\n\r\n  // Sprawdź dostępność regionalną\r\n  if ('region_restricted' in track && track.region_restricted === true) return false\r\n\r\n  // Sprawdź czy można streamować\r\n  if (track.streamable !== true) return false\r\n\r\n  // Sprawdź stan utworu\r\n  if (track.state && track.state !== 'finished') return false\r\n\r\n  // Sprawdź policy (blokady)\r\n  if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\r\n\r\n  // Sprawdź czy ma media/transcodings\r\n  if (!track.media || !track.media.transcodings || track.media.transcodings.length === 0) return false\r\n\r\n  // Sprawdź czy ma dostępne formaty streamowania\r\n  const hasValidFormat = track.media.transcodings.some((transcoding: any) =>\r\n    transcoding &&\r\n    transcoding.url &&\r\n    (transcoding.format?.protocol === 'hls' || transcoding.format?.protocol === 'progressive')\r\n  )\r\n\r\n  if (!hasValidFormat) return false\r\n\r\n  // Odrzucaj deleted/private tracks\r\n  if (track.sharing === 'private' && !track.streamable) return false\r\n\r\n  return true\r\n}\r\n\r\n/** @internal */\r\nexport const search = async (\r\n  options: SearchOptions,\r\n  axiosInstance: AxiosInstance,\r\n  clientID: string\r\n): Promise<SearchResponseAll> => {\r\n  let url = ''\r\n  if (!options.limit) options.limit = 20 // Zwiększ limit żeby mieć więcej opcji\r\n  if (!options.offset) options.offset = 0\r\n  if (!options.resourceType) options.resourceType = 'tracks'\r\n\r\n  // Obsługa zarówno options.query jak i options.q\r\n  const queryString = options.query || options.q\r\n\r\n  if (options.nextHref) {\r\n    url = appendURL(options.nextHref, 'client_id', clientID)\r\n  } else if (queryString) {\r\n    if (!validResourceTypes.includes(options.resourceType as any)) {\r\n      throw new Error(\r\n        `${options.resourceType} is not one of ${validResourceTypes\r\n          .map(str => `'${str}'`)\r\n          .join(', ')}`\r\n      )\r\n    }\r\n    url = appendURL(\r\n      `${baseURL}${options.resourceType === 'all' ? '' : `/${options.resourceType}`}`,\r\n      'client_id',\r\n      clientID,\r\n      'q',\r\n      queryString,\r\n      'limit',\r\n      String(options.limit),\r\n      'offset',\r\n      String(options.offset)\r\n    )\r\n  } else {\r\n    throw new Error('One of options.query, options.q, or options.nextHref is required')\r\n  }\r\n\r\n  const { data } = await axiosInstance.get(url)\r\n\r\n  if (options.resourceType === 'tracks' && Array.isArray(data.collection)) {\r\n    // Filtruj nieprawidłowe tracki\r\n    data.collection = data.collection.filter(isTrackValid)\r\n\r\n    // Sortuj wyniki na podstawie dokładności dopasowania do query\r\n    if (queryString) {\r\n      data.collection.sort((a: any, b: any) => {\r\n        const similarityA = calculateSimilarity(queryString, a.title)\r\n        const similarityB = calculateSimilarity(queryString, b.title)\r\n\r\n        // Bonus za oryginalną wersję\r\n        const originalBonusA = isOriginalVersion(a.title, queryString) ? 50 : 0\r\n        const originalBonusB = isOriginalVersion(b.title, queryString) ? 50 : 0\r\n\r\n        // Bonus za popularność (ale mniejszy niż dokładność)\r\n        const popularityA = (a.likes_count || 0) / 1000\r\n        const popularityB = (b.likes_count || 0) / 1000\r\n\r\n        const scoreA = similarityA + originalBonusA + popularityA\r\n        const scoreB = similarityB + originalBonusB + popularityB\r\n\r\n        return scoreB - scoreA\r\n      })\r\n    }\r\n\r\n    // Ogranicz do oryginalnego limitu (ale po filtrowaniu i sortowaniu)\r\n    data.collection = data.collection.slice(0, Math.min(options.limit, 10))\r\n  }\r\n\r\n  return data as SearchResponseAll\r\n}\r\n\r\n/** @internal */\r\nexport const related = async <T extends TrackInfo>(\r\n  id: number,\r\n  limit = 10,\r\n  offset = 0,\r\n  axiosInstance: AxiosInstance,\r\n  clientID: string\r\n): Promise<RelatedResponse<T>> => {\r\n  const { data } = await axiosInstance.get(\r\n    appendURL(\r\n      `https://api-v2.soundcloud.com/tracks/${id}/related`,\r\n      'client_id',\r\n      clientID,\r\n      'offset',\r\n      String(offset),\r\n      'limit',\r\n      String(limit)\r\n    )\r\n  )\r\n\r\n  // Zastosuj podobne filtrowanie dla related tracks\r\n  if (Array.isArray(data.collection)) {\r\n    data.collection = data.collection.filter((track: any) => {\r\n      if (!track || typeof track !== 'object') return false\r\n      if (!track.permalink_url || !track.title) return false\r\n\r\n      // Odrzucaj sample ~30s\r\n      if (\r\n        typeof track.duration === 'number' &&\r\n        track.duration >= 29500 &&\r\n        track.duration <= 30500\r\n      ) return false\r\n\r\n      // Odrzucaj zbyt krótkie\r\n      if (\r\n        typeof track.duration === 'number' &&\r\n        track.duration < 10000\r\n      ) return false\r\n\r\n      if (track.streamable !== true) return false\r\n      if (track.state && track.state !== 'finished') return false\r\n      if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\r\n\r\n      return true\r\n    })\r\n  }\r\n\r\n  return data as RelatedResponse<T>\r\n}\r\n","import type { AxiosInstance } from 'axios'\r\nimport { download } from './download'\r\nimport { getSetInfo } from './info'\r\n\r\nexport const downloadPlaylist = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<[ReadableStream<any>[], String[]]> => {\r\n  const info = await getSetInfo(url, clientID, axiosInstance)\r\n\r\n  const trackNames = []\r\n  const result = await Promise.all(info.tracks.map(track => {\r\n    const p = download(track.permalink_url, clientID, axiosInstance)\r\n    trackNames.push(track.title)\r\n    return p\r\n  }))\r\n\r\n  return [result, trackNames]\r\n}\r\n","import type { AxiosInstance } from 'axios'\r\nimport type { TrackInfo } from './info'\r\nimport { appendURL, kindMismatchError, type PaginatedQuery } from './util'\r\n\r\nconst baseURL = 'https://api-v2.soundcloud.com/users/'\r\n\r\nexport interface Like {\r\n  // eslint-disable-next-line camelcase\r\n  created_at: string,\r\n  kind: string,\r\n  track: TrackInfo\r\n}\r\n\r\nexport interface GetLikesOptions {\r\n  profileUrl?: string\r\n  id?: number\r\n  limit?: number // -1 indicates no limit\r\n  offset?: number\r\n  nextHref?: string\r\n}\r\n\r\n/** @internal */\r\nexport const getLikes = async (options: GetLikesOptions, clientID: string, axiosInstance: AxiosInstance): Promise<PaginatedQuery<Like>> => {\r\n  let u = ''\r\n  if (!options.nextHref) {\r\n    if (options.limit === undefined) options.limit = -1\r\n    if (options.offset === undefined) options.offset = 0\r\n    u = appendURL(\r\n      `https://api-v2.soundcloud.com/users/${options.id}/likes`,\r\n      'client_id', clientID,\r\n      'limit', String(options.limit === -1 ? 200 : options.limit),\r\n      'offset', String(options.offset))\r\n  } else {\r\n    u = appendURL(options.nextHref, 'client_id', clientID)\r\n  }\r\n\r\n  let response!: PaginatedQuery<Like>\r\n  let nextHref: string | undefined = 'start'\r\n\r\n  // If options.limit > 0, query each page of likes until we have collected\r\n  // `options.limit` liked tracks.\r\n  // If options.limit === -1, query every page of likes\r\n  while (nextHref && (options.limit > 0 || options.limit === -1)) {\r\n    const { data } = await axiosInstance.get(u)\r\n    const query = data as PaginatedQuery<Like>\r\n\r\n    if (!query.collection) throw new Error('Invalid JSON response received')\r\n    if (query.collection.length === 0) return data\r\n    if (query.collection[0].kind !== 'like') throw kindMismatchError('like', query.collection[0].kind)\r\n\r\n    // Only add tracks (for now)\r\n    query.collection = query.collection.reduce<Like[]>((prev, curr) =>\r\n      curr.track ? prev.concat(curr) : prev,\r\n      [])\r\n\r\n    if (!response) {\r\n      response = query\r\n    } else {\r\n      response.collection.push(...query.collection)\r\n    }\r\n\r\n    if (options.limit !== -1) {\r\n      options.limit -= query.collection.length\r\n      // We have collected enough likes\r\n      if (options.limit <= 0) break\r\n    }\r\n\r\n    nextHref = query.next_href\r\n    if (nextHref) {\r\n      if (options.limit !== -1) {\r\n        const url = new URL(nextHref)\r\n        url.searchParams.set('limit', String(options.limit))\r\n        nextHref = url.toString()\r\n      }\r\n      u = appendURL(nextHref, 'client_id', clientID)\r\n    }\r\n  }\r\n\r\n  return response\r\n}\r\n","import type { AxiosInstance } from 'axios'\r\nimport type { User } from './info'\r\nimport { appendURL, resolveURL } from './util'\r\n\r\n/** @internal */\r\nexport const getUser = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<User> => {\r\n  const u = appendURL(resolveURL, 'url', url, 'client_id', clientID)\r\n  const { data } = await axiosInstance.get(u)\r\n\r\n  if (!(data as User).avatar_url) throw new Error('JSON response is not a user. Is profile URL correct? : ' + url)\r\n\r\n  return data as User\r\n}\r\n","import sckey from 'soundcloud-key-fetch'\r\n\r\nimport getInfo, { getSetInfo, getTrackInfoByID, type Transcoding, type TrackInfo, type User } from './info'\r\nimport filterMedia, { type FilterPredicateObject } from './filter-media'\r\nimport { download, fromMediaObj } from './download'\r\n\r\nimport isValidURL, { convertFirebaseURL, isFirebaseURL, isPersonalizedTrackURL, isPlaylistURL, stripMobilePrefix } from './url'\r\n\r\nimport STREAMING_PROTOCOLS, { _PROTOCOLS } from './protocols'\r\nimport FORMATS, { _FORMATS } from './formats'\r\nimport { search, related, type SoundcloudResource, type SearchOptions } from './search'\r\nimport { downloadPlaylist } from './download-playlist'\r\nimport axios, { type AxiosInstance, type AxiosError } from 'axios'\r\n\r\nimport * as path from 'path'\r\nimport * as fs from 'fs'\r\nimport { type PaginatedQuery } from './util'\r\nimport { getLikes, type GetLikesOptions, type Like } from './likes'\r\nimport { getUser } from './user'\r\n\r\n// Nowe typy błędów dla lepszej obsługi\r\nexport enum SCDLErrorType {\r\n  NETWORK_ERROR = 'NETWORK_ERROR',\r\n  INVALID_URL = 'INVALID_URL',\r\n  CLIENT_ID_ERROR = 'CLIENT_ID_ERROR',\r\n  TRACK_NOT_FOUND = 'TRACK_NOT_FOUND',\r\n  REGION_RESTRICTED = 'REGION_RESTRICTED',\r\n  NOT_STREAMABLE = 'NOT_STREAMABLE',\r\n  SAMPLE_TRACK = 'SAMPLE_TRACK',\r\n  FORMAT_NOT_FOUND = 'FORMAT_NOT_FOUND',\r\n  FILE_SYSTEM_ERROR = 'FILE_SYSTEM_ERROR',\r\n  PARSING_ERROR = 'PARSING_ERROR',\r\n  RATE_LIMITED = 'RATE_LIMITED'\r\n}\r\n\r\nexport class SCDLError extends Error {\r\n  public readonly type: SCDLErrorType\r\n  public readonly originalError?: Error\r\n  public readonly url?: string\r\n  public readonly retryAfter?: number\r\n\r\n  constructor(\r\n    message: string,\r\n    type: SCDLErrorType,\r\n    originalError?: Error,\r\n    url?: string,\r\n    retryAfter?: number\r\n  ) {\r\n    super(message)\r\n    this.name = 'SCDLError'\r\n    this.type = type\r\n    this.originalError = originalError\r\n    this.url = url\r\n    this.retryAfter = retryAfter\r\n    \r\n    // Zachowaj stack trace\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, SCDLError)\r\n    }\r\n  }\r\n}\r\n\r\n/** @internal */\r\nconst downloadFormat = async (url: string, clientID: string, format: FORMATS, axiosInstance: AxiosInstance) => {\r\n  try {\r\n    const info = await getInfo(url, clientID, axiosInstance)\r\n    const filtered = filterMedia(info.media.transcodings, { format: format })\r\n    if (filtered.length === 0) {\r\n      throw new SCDLError(\r\n        `Nie można znaleźć mediów w określonym formacie: (${format})`,\r\n        SCDLErrorType.FORMAT_NOT_FOUND,\r\n        undefined,\r\n        url\r\n      )\r\n    }\r\n    return await fromMediaObj(filtered[0], clientID, axiosInstance)\r\n  } catch (error) {\r\n    if (error instanceof SCDLError) throw error\r\n    throw new SCDLError(\r\n      `Błąd podczas pobierania formatu: ${error.message}`,\r\n      SCDLErrorType.NETWORK_ERROR,\r\n      error as Error,\r\n      url\r\n    )\r\n  }\r\n}\r\n\r\ninterface ClientIDData {\r\n  clientID: string,\r\n  date: Date\r\n}\r\n\r\nexport interface SCDLOptions {\r\n  // Set a custom client ID to use\r\n  clientID?: string,\r\n  // Set to true to save client ID to file\r\n  saveClientID?: boolean,\r\n  // File path to save client ID, defaults to '../client_id.json\"\r\n  filePath?: string,\r\n  // Custom axios instance to use\r\n  axiosInstance?: AxiosInstance,\r\n  // Whether or not to automatically convert mobile links to regular links, defaults to true\r\n  stripMobilePrefix?: boolean,\r\n  // Whether or not to automatically convert SoundCloud Firebase links copied from the mobile app\r\n  // (e.g. https://soundcloud.app.goo.gl/xxxxxxxxx), defaults to true.\r\n  convertFirebaseLinks?: boolean,\r\n  // Nowe opcje\r\n  // Maximum number of retries for failed requests\r\n  maxRetries?: number,\r\n  // Base delay between retries in milliseconds\r\n  retryDelay?: number,\r\n  // Request timeout in milliseconds\r\n  timeout?: number,\r\n  // Whether to validate URLs before processing\r\n  validateUrls?: boolean\r\n}\r\n\r\n// Nowe interfejsy pomocnicze\r\ninterface RetryConfig {\r\n  maxRetries: number\r\n  retryDelay: number\r\n  currentAttempt: number\r\n}\r\n\r\nexport class SCDL {\r\n  STREAMING_PROTOCOLS: { [key: string]: STREAMING_PROTOCOLS }\r\n  FORMATS: { [key: string]: FORMATS }\r\n\r\n  private _clientID?: string\r\n  private _filePath?: string\r\n  private _maxRetries: number\r\n  private _retryDelay: number\r\n  private _timeout: number\r\n  private _validateUrls: boolean\r\n\r\n  axios: AxiosInstance\r\n  saveClientID = process.env.SAVE_CLIENT_ID ? process.env.SAVE_CLIENT_ID.toLowerCase() === 'true' : false\r\n\r\n  stripMobilePrefix: boolean\r\n  convertFirebaseLinks: boolean\r\n\r\n  constructor (options?: SCDLOptions) {\r\n    if (!options) options = {}\r\n    \r\n    // Zachowaj starą logikę\r\n    if (options.saveClientID) {\r\n      this.saveClientID = options.saveClientID\r\n      if (options.filePath) this._filePath = options.filePath\r\n    } else {\r\n      if (options.clientID) {\r\n        this._clientID = options.clientID\r\n      }\r\n    }\r\n\r\n    // Nowe opcje z wartościami domyślnymi\r\n    this._maxRetries = options.maxRetries ?? 3\r\n    this._retryDelay = options.retryDelay ?? 1000\r\n    this._timeout = options.timeout ?? 30000\r\n    this._validateUrls = options.validateUrls ?? true\r\n\r\n    if (options.axiosInstance) {\r\n      this.setAxiosInstance(options.axiosInstance)\r\n    } else {\r\n      this.setAxiosInstance(axios)\r\n    }\r\n\r\n    // Konfiguruj axios z timeout i interceptorami\r\n    this._setupAxiosInterceptors()\r\n\r\n    if (options.stripMobilePrefix === undefined) options.stripMobilePrefix = true\r\n    if (options.convertFirebaseLinks === undefined) options.convertFirebaseLinks = true\r\n\r\n    this.stripMobilePrefix = options.stripMobilePrefix\r\n    this.convertFirebaseLinks = options.convertFirebaseLinks\r\n\r\n    // Ustaw protokoły i formaty\r\n    this.STREAMING_PROTOCOLS = _PROTOCOLS\r\n    this.FORMATS = _FORMATS\r\n  }\r\n  /**\r\n   * Parsuje nagłówek retry-after który może być w sekundach lub jako data HTTP\r\n   * @internal\r\n   */\r\n  private _parseRetryAfter(retryAfterHeader: string | number | undefined): number {\r\n    if (!retryAfterHeader) {\r\n      return this._retryDelay\r\n    }\r\n\r\n    const retryAfterStr = String(retryAfterHeader).trim()\r\n  \r\n    // Sprawdź czy to liczba (sekundy)\r\n    if (/^\\d+$/.test(retryAfterStr)) {\r\n      const seconds = parseInt(retryAfterStr, 10)\r\n      return Math.max(seconds * 1000, this._retryDelay) // Konwertuj na milisekundy\r\n    }\r\n\r\n    // Sprawdź czy to data HTTP (RFC 7231)\r\n    try {\r\n      const retryDate = new Date(retryAfterStr)\r\n    \r\n      // Sprawdź czy data jest poprawna\r\n      if (isNaN(retryDate.getTime())) {\r\n        console.warn(`Nieprawidłowy format retry-after: ${retryAfterStr}`)\r\n        return this._retryDelay\r\n      }\r\n\r\n      const now = new Date()\r\n      const delayMs = retryDate.getTime() - now.getTime()\r\n    \r\n      // Jeśli data jest w przeszłości lub za daleko w przyszłości (>1h), użyj domyślnego delay\r\n      if (delayMs <= 0) {\r\n        console.warn(`Retry-after data w przeszłości: ${retryAfterStr}`)\r\n        return this._retryDelay\r\n      }\r\n    \r\n      const oneHourMs = 60 * 60 * 1000\r\n      if (delayMs > oneHourMs) {\r\n        console.warn(`Retry-after data zbyt daleko w przyszłości: ${retryAfterStr}, używam 1 godziny`)\r\n        return oneHourMs\r\n      }\r\n  \r\n      return delayMs\r\n    } catch (error) {\r\n      console.warn(`Błąd parsowania retry-after jako data: ${retryAfterStr}`, error)\r\n      return this._retryDelay\r\n    }\r\n  }\r\n  /**\r\n   * Konfiguruje interceptory dla axios\r\n   * @internal\r\n   */\r\n  private _setupAxiosInterceptors() {\r\n    this.axios.defaults.timeout = this._timeout\r\n\r\n    // Response interceptor dla obsługi błędów\r\n    this.axios.interceptors.response.use(\r\n      (response) => response,\r\n      (error: AxiosError) => {\r\n        if (error.response) {\r\n          const status = error.response.status\r\n          if (status === 429) {\r\n            const retryAfter = this._parseRetryAfter(error.response.headers['retry-after'])\r\n            throw new SCDLError(\r\n              'Przekroczono limit zapytań. Spróbuj ponownie później.',\r\n              SCDLErrorType.RATE_LIMITED,\r\n              error,\r\n              error.config?.url,\r\n              retryAfter\r\n            )\r\n          } else if (status === 404) {\r\n            throw new SCDLError(\r\n              'Nie znaleziono zasobu.',\r\n              SCDLErrorType.TRACK_NOT_FOUND,\r\n              error,\r\n              error.config?.url\r\n            )\r\n          } else if (status >= 500 && status < 600) {\r\n            throw new SCDLError(\r\n              `Błąd serwera (${status}): ${error.response.statusText}`,\r\n              SCDLErrorType.NETWORK_ERROR,\r\n              error,\r\n              error.config?.url\r\n            )\r\n          } else if (status === 403) {\r\n            throw new SCDLError(\r\n              'Brak dostępu do zasobu. Możliwe że zasób jest prywatny lub Client ID jest nieprawidłowy.',\r\n              SCDLErrorType.CLIENT_ID_ERROR,\r\n              error,\r\n              error.config?.url\r\n            )\r\n          } else if (status === 401) {\r\n            throw new SCDLError(\r\n              'Nieautoryzowany dostęp. Client ID może być nieprawidłowy.',\r\n              SCDLErrorType.CLIENT_ID_ERROR,\r\n              error,\r\n              error.config?.url\r\n            )\r\n          }\r\n        }\r\n      \r\n        if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {\r\n          throw new SCDLError(\r\n            'Przekroczono limit czasu żądania.',\r\n            SCDLErrorType.NETWORK_ERROR,\r\n            error,\r\n            error.config?.url\r\n          )\r\n        }\r\n      \r\n        if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\r\n          throw new SCDLError(\r\n            'Nie można połączyć się z serwerem SoundCloud.',\r\n            SCDLErrorType.NETWORK_ERROR,\r\n            error,\r\n            error.config?.url\r\n          )\r\n        }\r\n      \r\n        throw new SCDLError(\r\n          `Błąd sieci: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error,\r\n          error.config?.url\r\n        )\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Wykonuje operację z retry logic\r\n   * @internal\r\n   */\r\n  private async _withRetry<T>(\r\n    operation: () => Promise<T>,\r\n    config: Partial<RetryConfig> = {}\r\n  ): Promise<T> {\r\n    const retryConfig: RetryConfig = {\r\n      maxRetries: this._maxRetries,\r\n      retryDelay: this._retryDelay,\r\n      currentAttempt: 0,\r\n      ...config\r\n    }\r\n\r\n    while (retryConfig.currentAttempt <= retryConfig.maxRetries) {\r\n      try {\r\n        return await operation()\r\n      } catch (error) {\r\n        retryConfig.currentAttempt++\r\n        \r\n        if (error instanceof SCDLError) {\r\n          // Niektóre błędy nie powinny być retryowane\r\n          if ([\r\n            SCDLErrorType.INVALID_URL,\r\n            SCDLErrorType.REGION_RESTRICTED,\r\n            SCDLErrorType.NOT_STREAMABLE,\r\n            SCDLErrorType.SAMPLE_TRACK,\r\n            SCDLErrorType.FORMAT_NOT_FOUND\r\n          ].includes(error.type)) {\r\n            throw error\r\n          }\r\n\r\n          // Użyj retry-after dla rate limiting\r\n          if (error.type === SCDLErrorType.RATE_LIMITED && error.retryAfter) {\r\n            if (retryConfig.currentAttempt <= retryConfig.maxRetries) {\r\n              await this._delay(error.retryAfter)\r\n              continue\r\n            }\r\n          }\r\n        }\r\n\r\n        if (retryConfig.currentAttempt > retryConfig.maxRetries) {\r\n          throw error\r\n        }\r\n\r\n        // Exponential backoff\r\n        const delay = retryConfig.retryDelay * Math.pow(2, retryConfig.currentAttempt - 1)\r\n        await this._delay(delay)\r\n      }\r\n    }\r\n\r\n    throw new Error('Nieoczekiwany błąd w logice retry')\r\n  }\r\n\r\n  /**\r\n   * Pomocnicza funkcja delay\r\n   * @internal\r\n   */\r\n  private _delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n\r\n  /**\r\n   * Waliduje URL z lepszą obsługą błędów\r\n   * @internal\r\n   */\r\n  private _validateUrl(url: string, operation: string): void {\r\n    if (!this._validateUrls) return\r\n\r\n    try {\r\n      if (!url || typeof url !== 'string') {\r\n        throw new SCDLError(\r\n          'URL musi być niepustym stringiem.',\r\n          SCDLErrorType.INVALID_URL,\r\n          undefined,\r\n          url\r\n        )\r\n      }\r\n\r\n      if (!this.isValidUrl(url)) {\r\n        throw new SCDLError(\r\n          `Nieprawidłowy URL SoundCloud: ${url}`,\r\n          SCDLErrorType.INVALID_URL,\r\n          undefined,\r\n          url\r\n        )\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof SCDLError) throw error\r\n      throw new SCDLError(\r\n        `Błąd podczas walidacji URL dla operacji ${operation}: ${error.message}`,\r\n        SCDLErrorType.INVALID_URL,\r\n        error as Error,\r\n        url\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a media Transcoding that matches the given predicate object\r\n   * @param media - The Transcodings to filter\r\n   * @param predicateObj - The desired Transcoding object to match\r\n   * @returns An array of Transcodings that match the predicate object\r\n   */\r\n  filterMedia (media: Transcoding[], predicateObj: FilterPredicateObject) {\r\n    try {\r\n      return filterMedia(media, predicateObj)\r\n    } catch (error) {\r\n      throw new SCDLError(\r\n        `Błąd podczas filtrowania mediów: ${error.message}`,\r\n        SCDLErrorType.PARSING_ERROR,\r\n        error as Error\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the audio of a given track. It returns the first format found.\r\n   *\r\n   * @param url - The URL of the Soundcloud track\r\n   * @param useDirectLink - Whether or not to use the download link if the artist has set the track to be downloadable. This has erratic behaviour on some environments.\r\n   * @returns A ReadableStream containing the audio data\r\n  */\r\n  async download (url: string, useDirectLink = true) {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'download')\r\n      \r\n      try {\r\n        // POBIERZ INFO O TRACKU\r\n        const info = await this.getInfo(url)\r\n        \r\n        // ODRZUĆ SAMPLE ~30s (+/- 0.6s) I OGRANICZENIA REGIONALNE\r\n        if (\r\n          typeof info.duration === 'number' &&\r\n          info.duration >= 29500 &&\r\n          info.duration <= 30500\r\n        ) {\r\n          throw new SCDLError(\r\n            'Ten utwór to najprawdopodobniej 30-sekundowy sample/prewka SoundCloud!',\r\n            SCDLErrorType.SAMPLE_TRACK,\r\n            undefined,\r\n            url\r\n          )\r\n        }\r\n        \r\n        if ('region_restricted' in info && info.region_restricted === true) {\r\n          throw new SCDLError(\r\n            'Ten utwór jest niedostępny w Twoim regionie!',\r\n            SCDLErrorType.REGION_RESTRICTED,\r\n            undefined,\r\n            url\r\n          )\r\n        }\r\n        \r\n        if (info.streamable !== true) {\r\n          throw new SCDLError(\r\n            'Nie można streamować tego utworu!',\r\n            SCDLErrorType.NOT_STREAMABLE,\r\n            undefined,\r\n            url\r\n          )\r\n        }\r\n        \r\n        // Jeśli przeszedł checki, pobieraj!\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return download(preparedUrl, await this.getClientID(), this.axios, useDirectLink)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania utworu: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   *  Get the audio of a given track with the specified format\r\n   * @param url - The URL of the Soundcloud track\r\n   * @param format - The desired format\r\n  */\r\n  async downloadFormat (url: string, format: FORMATS) {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'downloadFormat')\r\n      \r\n      try {\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return downloadFormat(preparedUrl, await this.getClientID(), format, this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania formatu ${format}: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns info about a given track.\r\n   * @param url - URL of the Soundcloud track\r\n   * @returns Info about the track\r\n  */\r\n  async getInfo (url: string) {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'getInfo')\r\n      \r\n      try {\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return getInfo(preparedUrl, await this.getClientID(), this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania informacji o utworze: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns info about the given track(s) specified by ID.\r\n   * @param ids - The ID(s) of the tracks\r\n   * @returns Info about the track\r\n   */\r\n  async getTrackInfoByID (ids: number[], playlistID?: number, playlistSecretToken?: string) {\r\n    return this._withRetry(async () => {\r\n      try {\r\n        if (!Array.isArray(ids) || ids.length === 0) {\r\n          throw new SCDLError(\r\n            'IDs muszą być niepustą tablicą liczb.',\r\n            SCDLErrorType.INVALID_URL\r\n          )\r\n        }\r\n\r\n        return getTrackInfoByID(await this.getClientID(), this.axios, ids, playlistID, playlistSecretToken)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania informacji o utworach po ID: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns info about the given set\r\n   * @param url - URL of the Soundcloud set\r\n   * @returns Info about the set\r\n   */\r\n  async getSetInfo (url: string) {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'getSetInfo')\r\n      \r\n      try {\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return getSetInfo(preparedUrl, await this.getClientID(), this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania informacji o secie: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Searches for tracks/playlists for the given query\r\n   * @param options - The search option\r\n   * @returns SearchResponse\r\n   */\r\n  async search (options: SearchOptions) {\r\n    return this._withRetry(async () => {\r\n      try {\r\n        if (!options || (!options.q && !options.query)) {\r\n          throw new SCDLError(\r\n            'Opcje wyszukiwania muszą zawierać query (q) lub query.',\r\n            SCDLErrorType.INVALID_URL\r\n          )\r\n        }\r\n\r\n        return search(options, this.axios, await this.getClientID())\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas wyszukiwania: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Finds related tracks to the given track specified by ID\r\n   * @param id - The ID of the track\r\n   * @param limit - The number of results to return\r\n   * @param offset - Used for pagination, set to 0 if you will not use this feature.\r\n   */\r\n  async related (id: number, limit: number, offset = 0) {\r\n    return this._withRetry(async () => {\r\n      try {\r\n        if (!Number.isInteger(id) || id <= 0) {\r\n          throw new SCDLError(\r\n            'ID musi być dodatnią liczbą całkowitą.',\r\n            SCDLErrorType.INVALID_URL\r\n          )\r\n        }\r\n\r\n        if (!Number.isInteger(limit) || limit <= 0) {\r\n          throw new SCDLError(\r\n            'Limit musi być dodatnią liczbą całkowitą.',\r\n            SCDLErrorType.INVALID_URL\r\n          )\r\n        }\r\n\r\n        return related(id, limit, offset, this.axios, await this.getClientID())\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania powiązanych utworów: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns the audio streams and titles of the tracks in the given playlist.\r\n   * @param url - The url of the playlist\r\n   */\r\n  async downloadPlaylist (url: string): Promise<[ReadableStream<any>[], String[]]> {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'downloadPlaylist')\r\n      \r\n      try {\r\n        if (!this.isPlaylistURL(url)) {\r\n          throw new SCDLError(\r\n            'URL nie jest prawidłowym linkiem do playlisty SoundCloud.',\r\n            SCDLErrorType.INVALID_URL,\r\n            undefined,\r\n            url\r\n          )\r\n        }\r\n\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return downloadPlaylist(preparedUrl, await this.getClientID(), this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania playlisty: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns track information for a user's likes\r\n   * @param options - Can either be the profile URL of the user, or their ID\r\n   * @returns - An array of tracks\r\n   */\r\n  async getLikes (options: GetLikesOptions): Promise<PaginatedQuery<Like>> {\r\n    return this._withRetry(async () => {\r\n      try {\r\n        let id: number\r\n        const clientID = await this.getClientID()\r\n        \r\n        if (options.id) {\r\n          id = options.id\r\n        } else if (options.profileUrl) {\r\n          this._validateUrl(options.profileUrl, 'getLikes')\r\n          const user = await getUser(await this.prepareURL(options.profileUrl), clientID, this.axios)\r\n          id = user.id\r\n        } else if (options.nextHref) {\r\n          return await getLikes(options, clientID, this.axios)\r\n        } else {\r\n          throw new SCDLError(\r\n            'options.id lub options.profileURL musi być podane.',\r\n            SCDLErrorType.INVALID_URL\r\n          )\r\n        }\r\n        \r\n        options.id = id\r\n        return getLikes(options, clientID, this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania polubień: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns information about a user\r\n   * @param url - The profile URL of the user\r\n   */\r\n  async getUser (url: string): Promise<User> {\r\n    return this._withRetry(async () => {\r\n      this._validateUrl(url, 'getUser')\r\n      \r\n      try {\r\n        const preparedUrl = await this.prepareURL(url)\r\n        return getUser(preparedUrl, await this.getClientID(), this.axios)\r\n      } catch (error) {\r\n        if (error instanceof SCDLError) throw error\r\n        throw new SCDLError(\r\n          `Błąd podczas pobierania informacji o użytkowniku: ${error.message}`,\r\n          SCDLErrorType.NETWORK_ERROR,\r\n          error as Error,\r\n          url\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Sets the instance of Axios to use to make requests to SoundCloud API\r\n   * @param instance - An instance of Axios\r\n   */\r\n  setAxiosInstance (instance: AxiosInstance) {\r\n    this.axios = instance\r\n    this._setupAxiosInterceptors()\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the given URL is a valid Soundcloud URL\r\n   * @param url - URL of the Soundcloud track\r\n  */\r\n  isValidUrl (url: string) {\r\n    try {\r\n      return isValidURL(url, this.convertFirebaseLinks, this.stripMobilePrefix)\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the given URL is a valid playlist SoundCloud URL\r\n   * @param url - The URL to check\r\n   */\r\n  isPlaylistURL (url: string) {\r\n    try {\r\n      return isPlaylistURL(url)\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the given URL is a personalized track URL. (of the form https://soundcloud.com/discover/sets/personalized-tracks::user-sdlkfjsldfljs:847104873)\r\n   * @param url - The URL to check\r\n   */\r\n  isPersonalizedTrackURL (url: string) {\r\n    try {\r\n      return isPersonalizedTrackURL(url)\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the given URL is a Firebase URL (of the form https://soundcloud.app.goo.gl/XXXXXXXX)\r\n   * @param url - The URL to check\r\n   */\r\n  isFirebaseURL (url: string) {\r\n    try {\r\n      return isFirebaseURL(url)\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  async getClientID (): Promise<string> {\r\n    try {\r\n      if (!this._clientID) {\r\n        await this.setClientID()\r\n      }\r\n\r\n      if (!this._clientID) {\r\n        throw new SCDLError(\r\n          'Nie można pobrać Client ID.',\r\n          SCDLErrorType.CLIENT_ID_ERROR\r\n        )\r\n      }\r\n\r\n      return this._clientID\r\n    } catch (error) {\r\n      if (error instanceof SCDLError) throw error\r\n      throw new SCDLError(\r\n        `Błąd podczas pobierania Client ID: ${error.message}`,\r\n        SCDLErrorType.CLIENT_ID_ERROR,\r\n        error as Error\r\n      )\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  async setClientID (clientID?: string): Promise<string> {\r\n    try {\r\n      if (!clientID) {\r\n        if (!this._clientID) {\r\n          if (this.saveClientID) {\r\n            const filename = path.resolve(__dirname, this._filePath ? this._filePath : '../client_id.json')\r\n            const c = await this._getClientIDFromFile(filename)\r\n            if (!c) {\r\n              this._clientID = await sckey.fetchKey()\r\n              const data = {\r\n                clientID: this._clientID,\r\n                date: new Date().toISOString()\r\n              }\r\n              \r\n              try {\r\n                await fs.promises.writeFile(filename, JSON.stringify(data))\r\n              } catch (err) {\r\n                console.warn('Nie można zapisać client_id do pliku: ' + err)\r\n              }\r\n            } else {\r\n              this._clientID = c\r\n            }\r\n          } else {\r\n            this._clientID = await sckey.fetchKey()\r\n          }\r\n        }\r\n\r\n        return this._clientID\r\n      }\r\n\r\n      this._clientID = clientID\r\n      return clientID\r\n    } catch (error) {\r\n      throw new SCDLError(\r\n        `Błąd podczas ustawiania Client ID: ${error.message}`,\r\n        SCDLErrorType.CLIENT_ID_ERROR,\r\n        error as Error\r\n      )\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  private async _getClientIDFromFile (filename: string): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!fs.existsSync(filename)) return resolve('')\r\n\r\n      fs.readFile(filename, 'utf8', (err: NodeJS.ErrnoException | null, data: string) => {\r\n        if (err) return reject(new SCDLError(\r\n          `Błąd czytania pliku client_id.json: ${err.message}`,\r\n          SCDLErrorType.FILE_SYSTEM_ERROR,\r\n          err\r\n        ))\r\n        \r\n        let c: ClientIDData\r\n        try {\r\n          c = JSON.parse(data)\r\n        } catch (parseErr) {\r\n          return reject(new SCDLError(\r\n            'Błąd parsowania client_id.json',\r\n            SCDLErrorType.PARSING_ERROR,\r\n            parseErr as Error\r\n          ))\r\n        }\r\n        \r\n        if (!c.date || !c.clientID) {\r\n          return reject(new SCDLError(\r\n            \"Brakuje właściwości 'date' lub 'clientID' w client_id.json\",\r\n            SCDLErrorType.PARSING_ERROR\r\n          ))\r\n        }\r\n        \r\n        if (typeof c.clientID !== 'string') {\r\n          return reject(new SCDLError(\r\n            \"Właściwość 'clientID' nie jest stringiem w client_id.json\",\r\n            SCDLErrorType.PARSING_ERROR\r\n          ))\r\n        }\r\n        \r\n        if (typeof c.date !== 'string') {\r\n          return reject(new SCDLError(\r\n            \"Właściwość 'date' nie jest stringiem w client_id.json\",\r\n            SCDLErrorType.PARSING_ERROR\r\n          ))\r\n        }\r\n        \r\n        const d = new Date(c.date)\r\n        if (Number.isNaN(d.getTime())) {\r\n          return reject(new SCDLError(\r\n            \"Nieprawidłowy obiekt daty z 'date' w client_id.json\",\r\n            SCDLErrorType.PARSING_ERROR\r\n          ))\r\n        }\r\n        \r\n        const dayMs = 60 * 60 * 24 * 1000\r\n        if (new Date().getTime() - d.getTime() >= dayMs) {\r\n          // Starszy niż dzień, usuń\r\n          fs.unlink(filename, err => {\r\n            if (err) console.warn('Nie można usunąć client_id.json: ' + err)\r\n          })\r\n          return resolve('')\r\n        } else {\r\n          return resolve(c.clientID)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Prepares the given URL by stripping its mobile prefix (if this.stripMobilePrefix is true)\r\n   * and converting it to a regular URL (if this.convertFireBaseLinks is true.)\r\n   * @param url\r\n   */\r\n  async prepareURL (url: string): Promise<string> {\r\n    try {\r\n      let processedUrl = url\r\n      \r\n      if (this.stripMobilePrefix) {\r\n        processedUrl = stripMobilePrefix(processedUrl)\r\n      }\r\n      \r\n      if (this.convertFirebaseLinks && isFirebaseURL(processedUrl)) {\r\n        const converted = await convertFirebaseURL(processedUrl, this.axios)\r\n        if (!converted) {\r\n          throw new SCDLError(\r\n            'Nie można przekonwertować Firebase URL na prawidłowy link SoundCloud.',\r\n            SCDLErrorType.INVALID_URL,\r\n            undefined,\r\n            url\r\n          )\r\n        }\r\n        processedUrl = converted\r\n      }\r\n\r\n      return processedUrl\r\n    } catch (error) {\r\n      if (error instanceof SCDLError) throw error\r\n      throw new SCDLError(\r\n        `Błąd podczas przygotowywania URL: ${error.message}`,\r\n        SCDLErrorType.INVALID_URL,\r\n        error as Error,\r\n        url\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sprawdza czy błąd można ponowić\r\n   */\r\n  isRetryableError(error: SCDLError): boolean {\r\n    return ![\r\n      SCDLErrorType.INVALID_URL,\r\n      SCDLErrorType.REGION_RESTRICTED,\r\n      SCDLErrorType.NOT_STREAMABLE,\r\n      SCDLErrorType.SAMPLE_TRACK,\r\n      SCDLErrorType.FORMAT_NOT_FOUND\r\n    ].includes(error.type)\r\n  }\r\n\r\n  /**\r\n   * Czyści cache client ID (zmusza do ponownego pobrania)\r\n   */\r\n  clearClientID(): void {\r\n    this._clientID = undefined\r\n  }\r\n\r\n  /**\r\n   * Sprawdza status połączenia z SoundCloud API\r\n   */\r\n  async healthCheck(): Promise<{ status: 'ok' | 'error', clientID?: string, error?: string }> {\r\n    try {\r\n      const clientID = await this.getClientID()\r\n      \r\n      // Prosta próba zapytania do API\r\n      const testUrl = 'https://soundcloud.com/mt-eden/still-alive'\r\n      await this.getInfo(testUrl)\r\n      \r\n      return { \r\n        status: 'ok', \r\n        clientID: clientID.substring(0, 8) + '...' // Pokaż tylko początek dla bezpieczeństwa\r\n      }\r\n    } catch (error) {\r\n      return { \r\n        status: 'error', \r\n        error: error instanceof SCDLError ? error.message : (error as Error).message \r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ustawia opcje retry dla instancji\r\n   */\r\n  setRetryOptions(maxRetries: number, retryDelay: number): void {\r\n    if (!Number.isInteger(maxRetries) || maxRetries < 0) {\r\n      throw new SCDLError(\r\n        'maxRetries musi być nieujemną liczbą całkowitą.',\r\n        SCDLErrorType.INVALID_URL\r\n      )\r\n    }\r\n    \r\n    if (!Number.isInteger(retryDelay) || retryDelay < 0) {\r\n      throw new SCDLError(\r\n        'retryDelay musi być nieujemną liczbą całkowitą.',\r\n        SCDLErrorType.INVALID_URL\r\n      )\r\n    }\r\n\r\n    this._maxRetries = maxRetries\r\n    this._retryDelay = retryDelay\r\n  }\r\n\r\n  /**\r\n   * Pobiera obecne ustawienia retry\r\n   */\r\n  getRetryOptions(): { maxRetries: number, retryDelay: number } {\r\n    return {\r\n      maxRetries: this._maxRetries,\r\n      retryDelay: this._retryDelay\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ustawia timeout dla żądań\r\n   */\r\n  setTimeout(timeout: number): void {\r\n    if (!Number.isInteger(timeout) || timeout <= 0) {\r\n      throw new SCDLError(\r\n        'Timeout musi być dodatnią liczbą całkowitą.',\r\n        SCDLErrorType.INVALID_URL\r\n      )\r\n    }\r\n\r\n    this._timeout = timeout\r\n    this.axios.defaults.timeout = timeout\r\n  }\r\n\r\n  /**\r\n   * Pobiera obecny timeout\r\n   */\r\n  getTimeout(): number {\r\n    return this._timeout\r\n  }\r\n\r\n  /**\r\n   * Włącza/wyłącza walidację URL\r\n   */\r\n  setUrlValidation(validate: boolean): void {\r\n    this._validateUrls = validate\r\n  }\r\n\r\n  /**\r\n   * Sprawdza czy walidacja URL jest włączona\r\n   */\r\n  isUrlValidationEnabled(): boolean {\r\n    return this._validateUrls\r\n  }\r\n}\r\n\r\n// SCDL instance with default configuration\r\nconst scdl = new SCDL()\r\n\r\n// Creates an instance of SCDL with custom configuration\r\nconst create = (options: SCDLOptions): SCDL => new SCDL(options)\r\n\r\nexport { create, SCDLErrorType }\r\n\r\nscdl.STREAMING_PROTOCOLS = _PROTOCOLS\r\nscdl.FORMATS = _FORMATS\r\n\r\nexport default scdl;\r\n"],"mappings":"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"}