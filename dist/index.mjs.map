{"version":3,"file":"index.mjs","names":["URL","ids","info","id: number","fromURLBase: fromURLFunctionBase","getInfo","response: PaginatedQuery<Like>","getInfo","filterMedia","id: number","isValidURL","c: ClientIDData","err"],"sources":["../src/util.ts","../src/info.ts","../src/filter-media.ts","../src/download.ts","../src/url.ts","../src/protocols.ts","../src/formats.ts","../src/search.ts","../src/download-playlist.ts","../src/likes.ts","../src/user.ts","../src/index.ts"],"sourcesContent":["/** @internal @packageDocumentation */\nimport { URL } from 'url'\nimport { AxiosError } from 'axios'\n\n/* eslint-disable camelcase */\nexport interface PaginatedQuery<T> {\n  collection: T[],\n  total_results?: number, // is omitted if limit parameter is supplied\n  next_href: string,\n  query_urn: string\n}\n\nexport const resolveURL = 'https://api-v2.soundcloud.com/resolve'\nexport const handleRequestErrs = (err: AxiosError): Error => {\n  if (!err.response?.status) {\n    return err;\n  }\n\n  let descriptiveMessage = err.message;\n\n  switch (err.response.status) {\n    case 401:\n      descriptiveMessage = 'Authentication failed. Is your Client ID correct?';\n      break;\n    case 404:\n      descriptiveMessage = 'Resource not found. It may be private or the URL is incorrect.';\n      break;\n\n  }\n\n\n  return new Error(descriptiveMessage, { cause: err });\n}\n\nexport const appendURL = (url: string, ...params: string[]) => {\n  const u = new URL(url)\n  params.forEach((val, idx) => {\n    if (idx % 2 === 0) u.searchParams.append(val, params[idx + 1])\n  })\n  return u.href\n}\n\nexport const extractIDFromPersonalizedTrackURL = (url: string): string => {\n  if (!url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) return ''\n\n  const split = url.split(':')\n  if (split.length < 5) return ''\n  return split[4]\n}\n\nexport const kindMismatchError = (expected: string, received: string): Error => new Error(`Expected resouce of kind: (${expected}), received: (${received})`)\n","/* eslint-disable camelcase */\nimport { AxiosInstance } from 'axios'\nimport { handleRequestErrs, appendURL, extractIDFromPersonalizedTrackURL } from './util'\n\nimport STREAMING_PROTOCOLS from './protocols'\nimport FORMATS from './formats'\n\n/**\n * A Soundcloud user\n */\nexport interface User {\n  kind: string,\n  avatar_url: string,\n  city: string,\n  comments_count: number,\n  country_code: string,\n  created_at: string,\n  description: string,\n  followers_count: number,\n  followings_count: number,\n  first_name: string,\n  full_name: string,\n  groups_count: number,\n  id: number,\n  last_name: string,\n  permalink_url: string,\n  uri: string,\n  username: string\n}\n\n/**\n * Details about the track\n */\nexport interface TrackInfo {\n  kind: string\n  monetization_model: string,\n  id: number,\n  policy: string,\n  comment_count?: number,\n  full_duration?: number,\n  downloadable?: false,\n  created_at?: string,\n  description?: string,\n  media?: { transcodings: Transcoding[] },\n  title?: string,\n  publisher_metadata?: any,\n  duration?: number,\n  has_downloads_left?: boolean,\n  artwork_url?: string,\n  public?: boolean,\n  streamable?: true,\n  tag_list?: string,\n  genre?: string,\n  reposts_count?: number,\n  label_name?: string,\n  state?: string,\n  last_modified?: string,\n  commentable?: boolean,\n  uri?: string,\n  download_count?: number,\n  likes_count?: number,\n  display_date?: string,\n  user_id?: number,\n  waveform_url?: string,\n  permalink?: string,\n  permalink_url?: string,\n  user?: User,\n  playback_count?: number\n}\n\n/**\n * Details about a Set\n */\nexport interface SetInfo {\n  duration: number,\n  permalink_url: string,\n  reposts_count: number,\n  genre: string,\n  permalink: string,\n  purchase_url?: string,\n  description?: string,\n  uri: string,\n  label_name?: string,\n  tag_list: string,\n  set_type: string,\n  public: boolean,\n  track_count: number,\n  user_id: number,\n  last_modified: string,\n  license: string,\n  tracks: TrackInfo[],\n  id: number,\n  release_date?: string,\n  display_date: string,\n  sharing: string,\n  secret_token?: string,\n  created_at: string,\n  likes_count: number,\n  kind: string,\n  purchase_title?: string,\n  managed_by_feeds: boolean,\n  artwork_url?: string,\n  is_album: boolean,\n  user: User,\n  published_at: string,\n  embeddable_by: string\n}\n\n/**\n * Represents an audio link to a Soundcloud Track\n */\nexport interface Transcoding {\n  url: string,\n  preset: string,\n  snipped: boolean,\n  format: { protocol: STREAMING_PROTOCOLS, mime_type: FORMATS }\n}\n\nconst getTrackInfoBase = async (clientID: string, axiosRef: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string): Promise<TrackInfo[]> => {\n  let url = appendURL('https://api-v2.soundcloud.com/tracks', 'ids', ids.join(','), 'client_id', clientID)\n  if (playlistID && playlistSecretToken) {\n    url = appendURL(url, 'playlistId', '' + playlistID, 'playlistSecretToken', playlistSecretToken)\n  }\n  try {\n    const { data } = await axiosRef.get(url)\n\n    return data as TrackInfo[]\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\n/** @internal */\nexport const getInfoBase = async <T extends TrackInfo | SetInfo>(url: string, clientID: string, axiosRef: AxiosInstance): Promise<T> => {\n  try {\n    const res = await axiosRef.get(appendURL('https://api-v2.soundcloud.com/resolve', 'url', url, 'client_id', clientID), {\n      withCredentials: true\n    })\n\n    return res.data as T\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\n/** @internal */\nconst getSetInfoBase = async (url: string, clientID: string, axiosRef: AxiosInstance): Promise<SetInfo> => {\n  const setInfo = await getInfoBase<SetInfo>(url, clientID, axiosRef)\n  const temp = [...setInfo.tracks].map(track => track.id)\n  const playlistID = setInfo.id\n  const playlistSecretToken = setInfo.secret_token\n  const incompleteTracks = setInfo.tracks.filter(track => !track.title)\n  if (incompleteTracks.length === 0) {\n    return setInfo\n  }\n  const completeTracks = setInfo.tracks.filter(track => track.title)\n\n  const ids = incompleteTracks.map(t => t.id)\n  if (ids.length > 50) {\n    const splitIds = []\n    for (let x = 0; x <= Math.floor(ids.length / 50); x++) {\n      splitIds.push([])\n    }\n\n    for (let x = 0; x < ids.length; x++) {\n      const i = Math.floor(x / 50)\n      splitIds[i].push(ids[x])\n    }\n\n    const promises = splitIds.map(async ids => await getTrackInfoByID(clientID, axiosRef, ids, playlistID, playlistSecretToken))\n    const info = await Promise.all(promises)\n    setInfo.tracks = completeTracks.concat(...info)\n    setInfo.tracks = sortTracks(setInfo.tracks, temp)\n    return setInfo\n  }\n  const info = await getTrackInfoByID(clientID, axiosRef, ids, playlistID, playlistSecretToken)\n\n  setInfo.tracks = completeTracks.concat(info)\n  setInfo.tracks = sortTracks(setInfo.tracks, temp)\n  return setInfo\n}\n\n/** @internal */\nconst sortTracks = (tracks: TrackInfo[], ids: number[]): TrackInfo[] => {\n  for (let i = 0; i < ids.length; i++) {\n    if (tracks[i].id !== ids[i]) {\n      for (let j = 0; j < tracks.length; j++) {\n        if (tracks[j].id === ids[i]) {\n          const temp = tracks[i]\n          tracks[i] = tracks[j]\n          tracks[j] = temp\n        }\n      }\n    }\n  }\n\n  return tracks\n}\n\n/** @internal */\nconst getInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<TrackInfo> => {\n  let data\n  if (url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) {\n    const idString = extractIDFromPersonalizedTrackURL(url)\n    if (!idString) throw new Error('Could not parse track ID from given URL: ' + url)\n    let id: number\n    try {\n      id = parseInt(idString)\n    } catch (err) {\n      throw new Error('Could not parse track ID from given URL: ' + url)\n    }\n\n    data = (await getTrackInfoByID(clientID, axiosInstance, [id]))[0]\n    if (!data) throw new Error('Could not find track with ID: ' + id)\n  } else {\n    data = await getInfoBase<TrackInfo>(url, clientID, axiosInstance)\n  }\n  if (!data.media) throw new Error('The given URL does not link to a Soundcloud track')\n  return data\n}\n\n/** @internal */\nexport const getSetInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<SetInfo> => {\n  const data = await getSetInfoBase(url, clientID, axiosInstance)\n  if (!data.tracks) throw new Error('The given URL does not link to a Soundcloud set')\n  return data\n}\n\n/** @intenral */\nexport const getTrackInfoByID = async (clientID: string, axiosInstance: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string) => {\n  return await getTrackInfoBase(clientID, axiosInstance, ids, playlistID, playlistSecretToken)\n}\nexport default getInfo\n","import { Transcoding } from './info'\nimport FORMATS from './formats'\nimport STREAMING_PROTOCOLS from './protocols'\n\nexport interface FilterPredicateObject {\n  protocol?: STREAMING_PROTOCOLS,\n  format?: FORMATS\n}\n\n/** @internal */\nconst filterMedia = (media: Transcoding[], predicateObj: FilterPredicateObject): Transcoding[] => {\n  return media.filter(({ format, snipped }) => {\n    let match = false\n    if (predicateObj.protocol) match = format.protocol === predicateObj.protocol\n    if (predicateObj.format) match = format.mime_type === predicateObj.format\n    // DODAJ TO:\n    if (snipped) match = false\n    return match\n  })\n}\n\nexport default filterMedia\n","/** @internal @packageDocumentation */\n\nimport { AxiosInstance } from 'axios'\nimport m3u8stream from 'm3u8stream'\nimport { handleRequestErrs, appendURL } from './util'\nimport getInfo, { Transcoding } from './info'\n\nexport const getMediaURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<string> => {\n  const res = await axiosInstance.get(appendURL(url, 'client_id', clientID), {\n    headers: {\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.52 Safari/537.36',\n      Accept: '*/*',\n      'Accept-Encoding': 'gzip, deflate, br'\n    },\n    withCredentials: true\n  })\n  if (!res.data.url) throw new Error(`Invalid response from Soundcloud. Check if the URL provided is correct: ${url}`)\n  return res.data.url\n}\n\nexport const getProgressiveStream = async (mediaUrl: string, axiosInstance: AxiosInstance) => {\n  const r = await axiosInstance.get(mediaUrl, {\n    withCredentials: true,\n    responseType: 'stream'\n  })\n\n  return r.data\n}\n\nexport const getHLSStream = (mediaUrl: string) => m3u8stream(mediaUrl)\n\ntype fromURLFunctionBase = (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance) => Promise<any | m3u8stream.Stream>\n\nexport const fromURLBase: fromURLFunctionBase = async (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance):Promise<any | m3u8stream.Stream> => {\n  try {\n    const mediaUrl = await getMediaURLFunction(url, clientID, axiosInstance)\n\n    if (url.includes('/progressive')) {\n      return await getProgressiveStreamFunction(mediaUrl, axiosInstance)\n    }\n\n    return getHLSStreamFunction(mediaUrl)\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\nexport const fromURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => await fromURLBase(url, clientID, getMediaURL, getProgressiveStream, getHLSStream, axiosInstance)\n\nexport const fromMediaObjBase = async (media: Transcoding, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  fromURLFunction: typeof fromURL,\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\n  if (!validatemedia(media)) throw new Error('Invalid media object provided')\n  return await fromURLFunction(media.url, clientID, axiosInstance)\n}\n\nexport const fromMediaObj = async (media: Transcoding, clientID: string, axiosInstance: AxiosInstance) => await fromMediaObjBase(media, clientID, getMediaURL, getProgressiveStream, getHLSStream, fromURL, axiosInstance)\n\nexport const fromDownloadLink = async (id: number, clientID: string, axiosInstance: AxiosInstance) => {\n  const { data: { redirectUri } } = await axiosInstance.get(appendURL(`https://api-v2.soundcloud.com/tracks/${id}/download`, 'client_id', clientID))\n  const { data } = await axiosInstance.get(redirectUri, {\n    responseType: 'stream'\n  })\n\n  return data\n}\n\n/** @internal */\nexport const download = async (url: string, clientID: string, axiosInstance: AxiosInstance, useDownloadLink = true) => {\n  const info = await getInfo(url, clientID, axiosInstance)\n  \n  if (info.downloadable && useDownloadLink) {\n    try {\n      return await fromDownloadLink(info.id, clientID, axiosInstance)\n    } catch (err) {\n      console.log('Download link failed, trying transcoding...')\n    }\n  }\n\n  // Ulepszone wybieranie najlepszego transcoding\n  const availableTranscodings = info.media.transcodings.filter(t => \n    validatemedia(t) && \n    t.url && \n    t.format && \n    (t.format.protocol === 'hls' || t.format.protocol === 'progressive')\n  )\n\n  if (availableTranscodings.length === 0) {\n    throw new Error('No valid transcoding available for this track')\n  }\n\n  // Preferuj progressive nad HLS (lepiej działa z Discord)\n  const preferredTranscoding = availableTranscodings.find(t => \n    t.format.protocol === 'progressive'\n  ) || availableTranscodings[0]\n\n  // Spróbuj wszystkich dostępnych transcodings jeśli pierwszy nie działa\n  for (const transcoding of availableTranscodings) {\n    try {\n      return await fromMediaObj(transcoding, clientID, axiosInstance)\n    } catch (err) {\n      console.log(`Transcoding failed: ${transcoding.format.protocol}, trying next...`)\n      if (transcoding === availableTranscodings[availableTranscodings.length - 1]) {\n        throw err // Ostatni transcoding - rzuć błąd\n      }\n    }\n  }\n}\n\nconst validatemedia = (media: Transcoding) => {\n  if (!media || !media.url || !media.format) return false\n  if (!media.format.protocol) return false\n  // Sprawdź czy protocol jest obsługiwany\n  if (!['hls', 'progressive'].includes(media.format.protocol)) return false\n  return true\n}\n","import axios, { type AxiosInstance } from 'axios';\n\n// --- Wyrażenia regularne ---\n// Używamy stałych (const) z nazwami pisanymi wielkimi literami dla lepszej czytelności.\n\n/**\n * Regex dopasowujący standardowe i mobilne adresy URL SoundCloud.\n * Obsługuje:\n * - http://soundcloud.com/...\n * - https://soundcloud.com/...\n * - http://m.soundcloud.com/...\n * - https://m.soundcloud.com/...\n */\nconst SOUNDCLOUD_URL_REGEX = /^https?:\\/\\/(m\\.)?soundcloud\\.com\\/.+/;\n\n/**\n * Regex dopasowujący adresy URL skracacza linków Firebase używanego przez SoundCloud.\n */\n/**\n * Regex dopasowujący adresy URL skracaczy linków używanych przez SoundCloud (Firebase i on.soundcloud).\n * Obsługuje np:\n * - https://soundcloud.app.goo.gl/...\n * - https://on.soundcloud.com/...\n */\nconst FIREBASE_URL_REGEX = /^https?:\\/\\/(?:soundcloud\\.app\\.goo\\.gl|on\\.soundcloud\\.com)\\/.+/;\n\n/**\n * Ogólny regex do wyszukiwania (scrapowania) dowolnego adresu URL w tekście.\n * Używany do znalezienia docelowego linku SoundCloud w odpowiedzi z linku Firebase.\n */\nconst GENERIC_URL_SCRAPE_REGEX = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,500}\\.[a-zA-Z0-9()]{1,500}\\b([-a-zA-Z0-9()@:%_+.~#?&/\\\\=;]*)/g;\n\n// --- Funkcje pomocnicze ---\n\n/**\n * Sprawdza, czy podany ciąg znaków jest prawidłowym adresem URL SoundCloud (standardowym, mobilnym lub Firebase).\n * @param url - Adres URL do przetestowania.\n * @param testFirebase - Czy uwzględnić sprawdzanie linków Firebase (domyślnie true).\n * @returns `true`, jeśli adres URL jest prawidłowy, w przeciwnym razie `false`.\n */\nexport const isURL = (url: string, testFirebase: boolean = true, stripMobilePrefix?: boolean): boolean => {\n  if (typeof url !== 'string') return false;\n  // Sprawdza, czy pasuje do standardowego/mobilnego URL-a LUB (jeśli włączone) do URL-a Firebase.\n  return SOUNDCLOUD_URL_REGEX.test(url) || (testFirebase && FIREBASE_URL_REGEX.test(url));\n};\n\n/**\n * Sprawdza, czy URL prowadzi do playlisty (setu) na SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli URL jest playlistą, w przeciwnym razie `false`.\n */\nexport const isPlaylistURL = (url: string): boolean => {\n  // `isURL` sprawdza teraz również format linku Firebase, więc testFirebase ustawiamy na false,\n  // aby upewnić się, że analizujemy już rozwiązany URL SoundCloud.\n  if (!isURL(url, false) || !url.includes('/sets/')) {\n    return false;\n  }\n  try {\n    const parsedUrl = new URL(url);\n    // Dodatkowe, bardziej rygorystyczne sprawdzenie ścieżki\n    return parsedUrl.pathname.includes('/sets/');\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Sprawdza, czy URL jest linkiem do spersonalizowanej playlisty \"Odkrywaj\" na SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli URL jest spersonalizowaną playlistą, w przeciwnym razie `false`.\n */\nexport const isPersonalizedTrackURL = (url: string): boolean => {\n  if (!isURL(url, false)) return false;\n  return url.startsWith('https://soundcloud.com/discover/sets/personalized-tracks::');\n};\n\n/**\n * Usuwa prefiks mobilny 'm.' z adresu URL SoundCloud.\n * @param url - Adres URL do przetworzenia.\n * @returns Adres URL bez prefiksu mobilnego lub oryginalny URL, jeśli nie był to link mobilny.\n */\nexport const stripMobilePrefix = (url: string): string => {\n  try {\n    const urlObject = new URL(url);\n    if (urlObject.hostname === 'm.soundcloud.com') {\n      urlObject.hostname = 'soundcloud.com';\n      return urlObject.toString();\n    }\n    return url;\n  } catch {\n    // Zwraca oryginalny URL w przypadku błędu parsowania (np. nieprawidłowy URL)\n    return url;\n  }\n};\n\n/**\n * Sprawdza, czy URL jest skróconym linkiem Firebase od SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli to link Firebase, w przeciwnym razie `false`.\n */\n/**\n * Sprawdza, czy URL jest skróconym linkiem SoundCloud (np. Firebase shortener lub on.soundcloud.com).\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli to skrócony link SoundCloud, w przeciwnym razie `false`.\n */\nexport const isFirebaseURL = (url: string): boolean => {\n  return FIREBASE_URL_REGEX.test(url);\n};\n\n/**\n * Konwertuje skrócony link Firebase na pełny adres URL SoundCloud.\n * Pobiera zawartość strony z linku Firebase i wyszukuje w niej docelowy URL.\n * @param url - Skrócony URL Firebase (np. https://soundcloud.app.goo.gl/xyz).\n * @param axiosInstance - Instancja Axios do wykonania zapytania HTTP.\n * @returns Obietnica (Promise) rozwiązująca się do pełnego adresu URL SoundCloud lub `undefined`, jeśli nie można go znaleźć.\n * @throws Błąd, jeśli nie uda się znaleźć docelowego URL.\n */\nexport const convertFirebaseURL = async (url: string, axiosInstance: AxiosInstance): Promise<string | undefined> => {\n  const urlObject = new URL(url);\n  // Dodanie parametru 'd=1' może czasem pomóc w ominięciu przekierowań i uzyskaniu strony z metadanymi.\n  urlObject.searchParams.set('d', '1');\n\n  // Pobieramy zawartość HTML ze skróconego linku, ponieważ często zawiera on docelowy URL w tagach meta lub skryptach.\n  const { data: htmlContent } = await axiosInstance.get<string>(urlObject.toString());\n  \n  const allUrlsInHtml = htmlContent.match(GENERIC_URL_SCRAPE_REGEX);\n\n  if (!allUrlsInHtml) {\n    throw new Error(`Could not find any URL in the response from the Firebase URL: ${url}`);\n  }\n\n  // Znajdź pierwszy URL, który jest prawidłowym linkiem do SoundCloud.\n  const soundcloudUrl = allUrlsInHtml.find(match => SOUNDCLOUD_URL_REGEX.test(match));\n\n  if (!soundcloudUrl) {\n    return undefined;\n  }\n\n  // Czasami URL w odpowiedzi jest zakodowany (np. \\u003d zamiast =).\n  // Ta operacja dekoduje znaki Unicode do ich standardowej postaci.\n  // Przykład: '.../tracks\\u003d123' -> '.../tracks=123'\n  return soundcloudUrl.replace(/\\\\u([\\d\\w]{4})/gi, (_match, grp) =>\n    String.fromCharCode(parseInt(grp, 16)),\n  );\n};\n\n// Eksport domyślny pozostaje bez zmian dla zgodności wstecznej.\nexport default isURL;\n","/**\n * Soundcloud streams tracks using these protocols.\n */\nenum STREAMING_PROTOCOLS {\n  HLS = 'hls',\n  PROGRESSIVE = 'progressive'\n}\n\n/** @internal */\nexport const _PROTOCOLS = {\n  HLS: STREAMING_PROTOCOLS.HLS,\n  PROGRESSIVE: STREAMING_PROTOCOLS.PROGRESSIVE\n}\n\nexport default STREAMING_PROTOCOLS\n","/**\n * Audio formats a track can be encoded in.\n */\nexport enum FORMATS {\n  MP3 = 'audio/mpeg',\n  OPUS = 'audio/ogg; codecs=\"opus\"',\n  AAC = 'audio/aac',\n  AAC_LC = 'audio/aac-lc',         // Low Complexity AAC\n  FLAC = 'audio/flac',\n  WAV = 'audio/wav',\n  WEBM_OPUS = 'audio/webm; codecs=\"opus\"', // WebM container z Opus\n  OGG_VORBIS = 'audio/ogg; codecs=\"vorbis\"', // OGG z Vorbis\n  ALAC = 'audio/alac',               // Apple Lossless\n  AIFF = 'audio/aiff',               // AIFF PCM\n  M4A = 'audio/mp4; codecs=\"mp4a.40.2\"' // AAC w kontenerze M4A\n}\n\n/** @internal */\nexport const _FORMATS = {\n  MP3: FORMATS.MP3,\n  OPUS: FORMATS.OPUS,\n  AAC: FORMATS.AAC,\n  AAC_LC: FORMATS.AAC_LC,\n  FLAC: FORMATS.FLAC,\n  WAV: FORMATS.WAV,\n  WEBM_OPUS: FORMATS.WEBM_OPUS,\n  OGG_VORBIS: FORMATS.OGG_VORBIS,\n  ALAC: FORMATS.ALAC,\n  AIFF: FORMATS.AIFF,\n  M4A: FORMATS.M4A\n};\n\nexport default FORMATS;\n","/* eslint-disable camelcase */\nimport { AxiosInstance } from 'axios'\nimport { TrackInfo, User, SetInfo } from './info'\nimport { appendURL, PaginatedQuery } from './util'\n\nconst baseURL = 'https://api-v2.soundcloud.com/search'\n\nexport interface RelatedResponse<T> extends PaginatedQuery<T> {\n  variant: string\n}\n\nexport interface SearchOptions {\n  limit?: number,\n  offset?: number,\n  resourceType?: SoundcloudResource | 'all',\n  query?: string,\n  nextHref?: string\n}\n\nexport type SearchResponseAll = PaginatedQuery<User | SetInfo | TrackInfo>\nexport type SoundcloudResource = 'tracks' | 'users' | 'albums' | 'playlists'\n\nconst validResourceTypes = ['tracks', 'users', 'albums', 'playlists', 'all']\n\n// Funkcja do normalizacji stringów (usuwa znaki specjalne, akcenty, małe litery)\nconst normalizeString = (str: string): string => {\n  return str\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // usuń akcenty\n    .replace(/[^\\w\\s]/g, ' ') // zamień znaki specjalne na spacje\n    .replace(/\\s+/g, ' ') // zamień wielokrotne spacje na jedną\n    .trim()\n}\n\n// Funkcja do obliczania podobieństwa między tytułami\nconst calculateSimilarity = (query: string, title: string): number => {\n  const normalizedQuery = normalizeString(query)\n  const normalizedTitle = normalizeString(title)\n  \n  // Jeśli tytuły są identyczne po normalizacji - maksymalny wynik\n  if (normalizedQuery === normalizedTitle) {\n    return 1000\n  }\n  \n  // Sprawdź czy query jest dokładnie zawarte w tytule\n  if (normalizedTitle.includes(normalizedQuery)) {\n    return 800\n  }\n  \n  // Sprawdź czy wszystkie słowa z query są w tytule\n  const queryWords = normalizedQuery.split(' ').filter(word => word.length > 0)\n  const titleWords = normalizedTitle.split(' ').filter(word => word.length > 0)\n  \n  let matchingWords = 0\n  let exactMatches = 0\n  \n  queryWords.forEach(queryWord => {\n    // Sprawdź dokładne dopasowanie\n    if (titleWords.some(titleWord => titleWord === queryWord)) {\n      exactMatches++\n      matchingWords++\n    }\n    // Sprawdź częściowe dopasowanie (słowo zawiera się w innym)\n    else if (titleWords.some(titleWord => \n      titleWord.includes(queryWord) || queryWord.includes(titleWord)\n    )) {\n      matchingWords += 0.5\n    }\n  })\n  \n  // Kara za dodatkowe słowa w tytule (preferuj krótsze, dokładniejsze tytuły)\n  const extraWords = Math.max(0, titleWords.length - queryWords.length)\n  const lengthPenalty = extraWords * 10\n  \n  // Bonus za dokładne dopasowania\n  const exactMatchBonus = exactMatches * 100\n  \n  // Bazowy wynik na podstawie % dopasowanych słów\n  const baseScore = (matchingWords / queryWords.length) * 500\n  \n  return Math.max(0, baseScore + exactMatchBonus - lengthPenalty)\n}\n\n// Funkcja do sprawdzania czy to remix/cover/live version\nconst isOriginalVersion = (title: string, query: string): boolean => {\n  const normalizedTitle = normalizeString(title)\n  \n  const modifierKeywords = [\n    'remix', 'cover', 'live', 'acoustic', 'instrumental', 'karaoke',\n    'extended', 'radio edit', 'club mix', 'dub', 'version', 'edit',\n    'remaster', 'rework', 'bootleg', 'mashup', 'flip'\n  ]\n  \n  // Sprawdź czy tytuł zawiera słowa wskazujące na modyfikację\n  const hasModifiers = modifierKeywords.some(keyword => \n    normalizedTitle.includes(keyword)\n  )\n  \n  // Sprawdź czy query zawiera te słowa (jeśli tak, to użytkownik ich szuka)\n  const queryWantsModified = modifierKeywords.some(keyword => \n    normalizeString(query).includes(keyword)\n  )\n  \n  // Jeśli query nie zawiera modyfikatorów, ale tytuł tak - to prawdopodobnie nie oryginał\n  return !hasModifiers || queryWantsModified\n}\n\n/** @internal */\nexport const search = async (\n  options: SearchOptions,\n  axiosInstance: AxiosInstance,\n  clientID: string\n): Promise<SearchResponseAll> => {\n  let url = ''\n  if (!options.limit) options.limit = 20 // Zwiększ limit żeby mieć więcej opcji\n  if (!options.offset) options.offset = 0\n  if (!options.resourceType) options.resourceType = 'tracks'\n  \n  if (options.nextHref) {\n    url = appendURL(options.nextHref, 'client_id', clientID)\n  } else if (options.query) {\n    if (!validResourceTypes.includes(options.resourceType)) {\n      throw new Error(\n        `${options.resourceType} is not one of ${validResourceTypes\n          .map(str => `'${str}'`)\n          .join(', ')}`\n      )\n    }\n    url = appendURL(\n      `${baseURL}${options.resourceType === 'all' ? '' : `/${options.resourceType}`}`,\n      'client_id',\n      clientID,\n      'q',\n      options.query,\n      'limit',\n      '' + options.limit,\n      'offset',\n      '' + options.offset\n    )\n  } else {\n    throw new Error('One of options.query or options.nextHref is required')\n  }\n\n  const { data } = await axiosInstance.get(url)\n  \n  if (options.resourceType === 'tracks' && Array.isArray(data.collection)) {\n    // PRZYWRÓCONE SPRAWDZANIE SEKUND I INNE FILTRY\n    data.collection = data.collection.filter((track: any) => {\n      // Podstawowe sprawdzenia\n      if (!track || typeof track !== 'object') return false\n      if (!track.permalink_url || !track.title) return false\n      \n      // Odrzucaj sample o długości w pobliżu 30s (29.5–30.5 sekundy)\n      if (\n        typeof track.duration === 'number' &&\n        track.duration >= 29500 &&\n        track.duration <= 30500\n      ) return false\n      \n      // Sprawdź dostępność regionalną\n      if ('region_restricted' in track && track.region_restricted === true) return false\n      \n      // Sprawdź czy można streamować\n      if (track.streamable !== true) return false\n      \n      // Sprawdź stan utworu\n      if (track.state && track.state !== 'finished') return false\n      \n      // Sprawdź policy (blokady)\n      if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\n      \n      // Sprawdź czy ma media/transcodings\n      if (!track.media || !track.media.transcodings || track.media.transcodings.length === 0) return false\n      \n      // Sprawdź czy ma dostępne formaty streamowania\n      const hasValidFormat = track.media.transcodings.some((transcoding: any) => \n        transcoding && \n        transcoding.url && \n        (transcoding.format?.protocol === 'hls' || transcoding.format?.protocol === 'progressive')\n      )\n      \n      if (!hasValidFormat) return false\n      \n      // Odrzucaj deleted/private tracks\n      if (track.sharing === 'private' && !track.streamable) return false\n      \n      return true\n    })\n    \n    // Sortuj wyniki na podstawie dokładności dopasowania do query\n    if (options.query) {\n      data.collection.sort((a: any, b: any) => {\n        const similarityA = calculateSimilarity(options.query!, a.title)\n        const similarityB = calculateSimilarity(options.query!, b.title)\n        \n        // Bonus za oryginalną wersję\n        const originalBonusA = isOriginalVersion(a.title, options.query!) ? 50 : 0\n        const originalBonusB = isOriginalVersion(b.title, options.query!) ? 50 : 0\n        \n        // Bonus za popularność (ale mniejszy niż dokładność)\n        const popularityA = (a.likes_count || 0) / 1000\n        const popularityB = (b.likes_count || 0) / 1000\n        \n        const scoreA = similarityA + originalBonusA + popularityA\n        const scoreB = similarityB + originalBonusB + popularityB\n        \n        return scoreB - scoreA\n      })\n    }\n    \n    // Ogranicz do oryginalnego limitu (ale po filtrowaniu i sortowaniu)\n    data.collection = data.collection.slice(0, Math.min(options.limit, 10))\n  }\n  \n  return data as SearchResponseAll\n}\n\n/** @internal */\nexport const related = async <T extends TrackInfo>(\n  id: number,\n  limit = 10,\n  offset = 0,\n  axiosInstance: AxiosInstance,\n  clientID: string\n): Promise<RelatedResponse<T>> => {\n  const { data } = await axiosInstance.get(\n    appendURL(\n      `https://api-v2.soundcloud.com/tracks/${id}/related`,\n      'client_id',\n      clientID,\n      'offset',\n      '' + offset,\n      'limit',\n      '' + limit\n    )\n  )\n  \n  // Zastosuj podobne filtrowanie dla related tracks\n  if (Array.isArray(data.collection)) {\n    data.collection = data.collection.filter((track: any) => {\n      if (!track || typeof track !== 'object') return false\n      if (!track.permalink_url || !track.title) return false\n      \n      // Odrzucaj sample ~30s\n      if (\n        typeof track.duration === 'number' &&\n        track.duration >= 29500 &&\n        track.duration <= 30500\n      ) return false\n      \n      // Odrzucaj zbyt krótkie\n      if (\n        typeof track.duration === 'number' &&\n        track.duration < 10000\n      ) return false\n      \n      if (track.streamable !== true) return false\n      if (track.state && track.state !== 'finished') return false\n      if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\n      \n      return true\n    })\n  }\n  \n  return data as RelatedResponse<T>\n}\n","import { AxiosInstance } from 'axios'\nimport { download } from './download'\nimport { getSetInfo } from './info'\n\nexport const downloadPlaylist = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<[ReadableStream<any>[], String[]]> => {\n  const info = await getSetInfo(url, clientID, axiosInstance)\n\n  const trackNames = []\n  const result = await Promise.all(info.tracks.map(track => {\n    const p = download(track.permalink_url, clientID, axiosInstance)\n    trackNames.push(track.title)\n    return p\n  }))\n\n  return [result, trackNames]\n}\n","import { AxiosInstance } from 'axios'\nimport { TrackInfo } from './info'\nimport { appendURL, kindMismatchError, PaginatedQuery } from './util'\n\nconst baseURL = 'https://api-v2.soundcloud.com/users/'\n\nexport interface Like {\n    // eslint-disable-next-line camelcase\n    created_at: string,\n    kind: string,\n    track: TrackInfo\n}\n\nexport interface GetLikesOptions {\n  profileUrl?: string\n  id?: number\n  limit?: number // -1 indicates no limit\n  offset?: number\n  nextHref?: string\n}\n\n/** @internal */\nexport const getLikes = async (options: GetLikesOptions, clientID: string, axiosInstance: AxiosInstance): Promise<PaginatedQuery<Like>> => {\n  let u = ''\n  if (!options.nextHref) {\n    if (!options.limit) options.limit = -1\n    if (!options.offset) options.offset = 0\n    u = appendURL(\n      `https://api-v2.soundcloud.com/users/${options.id}/likes`,\n      'client_id', clientID,\n      'limit', '' + (options.limit === -1 ? 200 : options.limit),\n      'offset', '' + options.offset)\n  } else {\n    u = appendURL(options.nextHref, 'client_id', clientID)\n  }\n\n  let response: PaginatedQuery<Like>\n  let nextHref = 'start'\n\n  // If options.limit > 0, query each page of likes until we have collected\n  // `options.limit` liked tracks.\n  // If options.limit === -1, query every page of likes\n  while (nextHref && (options.limit > 0 || options.limit === -1)) {\n    const { data } = await axiosInstance.get(u)\n\n    const query = data as PaginatedQuery<Like>\n    if (!query.collection) throw new Error('Invalid JSON response received')\n    if (query.collection.length === 0) return data\n\n    if (query.collection[0].kind !== 'like') throw kindMismatchError('like', query.collection[0].kind)\n\n    // Only add tracks (for now)\n    query.collection = query.collection.reduce((prev, curr) => curr.track ? prev.concat(curr) : prev, [])\n    if (!response) {\n      response = query\n    } else {\n      response.collection.push(\n        ...query.collection\n      )\n    }\n\n    if (options.limit !== -1) {\n      options.limit -= query.collection.length\n      // We have collected enough likes\n      if (options.limit <= 0) break\n    }\n\n    nextHref = query.next_href\n    if (nextHref) {\n      if (options.limit !== -1) {\n        const url = new URL(nextHref)\n        url.searchParams.set('limit', '' + options.limit)\n        nextHref = url.toString()\n      }\n      u = appendURL(nextHref, 'client_id', clientID)\n    }\n  }\n\n  return response\n}\n","import { AxiosInstance } from 'axios'\nimport { User } from './info'\nimport { appendURL, resolveURL } from './util'\n\n/** @internal */\nexport const getUser = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<User> => {\n  const u = appendURL(resolveURL, 'url', url, 'client_id', clientID)\n  const { data } = await axiosInstance.get(u)\n\n  if (!(data as User).avatar_url) throw new Error('JSON response is not a user. Is profile URL correct? : ' + url)\n\n  return data as User\n}\n","import sckey from 'soundcloud-key-fetch'\n\nimport getInfo, { getSetInfo, Transcoding, getTrackInfoByID, TrackInfo, User } from './info'\nimport filterMedia, { FilterPredicateObject } from './filter-media'\nimport { download, fromMediaObj } from './download'\n\nimport isValidURL, { convertFirebaseURL, isFirebaseURL, isPersonalizedTrackURL, isPlaylistURL, stripMobilePrefix } from './url'\n\nimport STREAMING_PROTOCOLS, { _PROTOCOLS } from './protocols'\nimport FORMATS, { _FORMATS } from './formats'\nimport { search, related, SoundcloudResource, SearchOptions } from './search'\nimport { downloadPlaylist } from './download-playlist'\nimport axios, { AxiosInstance } from 'axios'\n\nimport * as path from 'path'\nimport * as fs from 'fs'\nimport { PaginatedQuery } from './util'\nimport { GetLikesOptions, getLikes, Like } from './likes'\nimport { getUser } from './user'\n\n/** @internal */\nconst downloadFormat = async (url: string, clientID: string, format: FORMATS, axiosInstance: AxiosInstance) => {\n  const info = await getInfo(url, clientID, axiosInstance)\n  const filtered = filterMedia(info.media.transcodings, { format: format })\n  if (filtered.length === 0) throw new Error(`Could not find media with specified format: (${format})`)\n  return await fromMediaObj(filtered[0], clientID, axiosInstance)\n}\n\ninterface ClientIDData {\n  clientID: string,\n  date: Date\n}\n\nexport interface SCDLOptions {\n  // Set a custom client ID to use\n  clientID?: string,\n  // Set to true to save client ID to file\n  saveClientID?: boolean,\n  // File path to save client ID, defaults to '../client_id.json\"\n  filePath?: string,\n  // Custom axios instance to use\n  axiosInstance?: AxiosInstance,\n  // Whether or not to automatically convert mobile links to regular links, defaults to true\n  stripMobilePrefix?: boolean,\n  // Whether or not to automatically convert SoundCloud Firebase links copied from the mobile app\n  // (e.g. https://soundcloud.app.goo.gl/xxxxxxxxx), defaults to true.\n  convertFirebaseLinks?: boolean,\n}\n\nexport class SCDL {\n  STREAMING_PROTOCOLS: { [key: string]: STREAMING_PROTOCOLS }\n  FORMATS: { [key: string]: FORMATS }\n\n  private _clientID?: string\n  private _filePath?: string\n\n  axios: AxiosInstance\n  saveClientID = process.env.SAVE_CLIENT_ID ? process.env.SAVE_CLIENT_ID.toLowerCase() === 'true' : false\n\n  stripMobilePrefix: boolean\n  convertFirebaseLinks: boolean\n\n  constructor (options?: SCDLOptions) {\n    if (!options) options = {}\n    if (options.saveClientID) {\n      this.saveClientID = options.saveClientID\n      if (options.filePath) this._filePath = options.filePath\n    } else {\n      if (options.clientID) {\n        this._clientID = options.clientID\n      }\n    }\n\n    if (options.axiosInstance) {\n      this.setAxiosInstance(options.axiosInstance)\n    } else {\n      this.setAxiosInstance(axios)\n    }\n\n    if (!options.stripMobilePrefix) options.stripMobilePrefix = true\n    if (!options.convertFirebaseLinks) options.convertFirebaseLinks = true\n\n    this.stripMobilePrefix = options.stripMobilePrefix\n    this.convertFirebaseLinks = options.convertFirebaseLinks\n  }\n\n  /**\n   * Returns a media Transcoding that matches the given predicate object\n   * @param media - The Transcodings to filter\n   * @param predicateObj - The desired Transcoding object to match\n   * @returns An array of Transcodings that match the predicate object\n   */\n  filterMedia (media: Transcoding[], predicateObj: FilterPredicateObject) {\n    return filterMedia(media, predicateObj)\n  }\n\n  /**\n   * Get the audio of a given track. It returns the first format found.\n   *\n   * @param url - The URL of the Soundcloud track\n   * @param useDirectLink - Whether or not to use the download link if the artist has set the track to be downloadable. This has erratic behaviour on some environments.\n   * @returns A ReadableStream containing the audio data\n  */\n  async download (url: string, useDirectLink = true) {\n    // POBIERZ INFO O TRACKU\n    const info = await this.getInfo(url)\n    // ODRZUĆ SAMPLE ~30s (+/- 0.6s) I OGRANICZENIA REGIONALNE\n    if (\n      typeof info.duration === 'number' &&\n      info.duration >= 29500 &&\n      info.duration <= 30500\n    ) {\n      throw new Error('Ten utwór to najprawdopodobniej 30-sekundowy sample/prewka SoundCloud!')\n    }\n    if ('region_restricted' in info && info.region_restricted === true) {\n      throw new Error('Ten utwór jest niedostępny w Twoim regionie!')\n    }\n    if (info.streamable !== true) {\n      throw new Error('Nie można streamować tego utworu!')\n    }\n    // Jeśli przeszedł checki, pobieraj!\n    return download(await this.prepareURL(url), await this.getClientID(), this.axios, useDirectLink)\n  }\n\n  /**\n   *  Get the audio of a given track with the specified format\n   * @param url - The URL of the Soundcloud track\n   * @param format - The desired format\n  */\n  async downloadFormat (url: string, format: FORMATS) {\n    return downloadFormat(await this.prepareURL(url), await this.getClientID(), format, this.axios)\n  }\n\n  /**\n   * Returns info about a given track.\n   * @param url - URL of the Soundcloud track\n   * @returns Info about the track\n  */\n  async getInfo (url: string) {\n    return getInfo(await this.prepareURL(url), await this.getClientID(), this.axios)\n  }\n\n  /**\n   * Returns info about the given track(s) specified by ID.\n   * @param ids - The ID(s) of the tracks\n   * @returns Info about the track\n   */\n  async getTrackInfoByID (ids: number[], playlistID?: number, playlistSecretToken?: string) {\n    return getTrackInfoByID(await this.getClientID(), this.axios, ids, playlistID, playlistSecretToken)\n  }\n\n  /**\n   * Returns info about the given set\n   * @param url - URL of the Soundcloud set\n   * @returns Info about the set\n   */\n  async getSetInfo (url: string) {\n    return getSetInfo(await this.prepareURL(url), await this.getClientID(), this.axios)\n  }\n\n  /**\n   * Searches for tracks/playlists for the given query\n   * @param options - The search option\n   * @returns SearchResponse\n   */\n  async search (options: SearchOptions) {\n    return search(options, this.axios, await this.getClientID())\n  }\n\n  /**\n   * Finds related tracks to the given track specified by ID\n   * @param id - The ID of the track\n   * @param limit - The number of results to return\n   * @param offset - Used for pagination, set to 0 if you will not use this feature.\n   */\n  async related (id: number, limit: number, offset = 0) {\n    return related(id, limit, offset, this.axios, await this.getClientID())\n  }\n\n  /**\n   * Returns the audio streams and titles of the tracks in the given playlist.\n   * @param url - The url of the playlist\n   */\n  async downloadPlaylist (url: string): Promise<[ReadableStream<any>[], String[]]> {\n    return downloadPlaylist(await this.prepareURL(url), await this.getClientID(), this.axios)\n  }\n\n  /**\n   * Returns track information for a user's likes\n   * @param options - Can either be the profile URL of the user, or their ID\n   * @returns - An array of tracks\n   */\n  async getLikes (options: GetLikesOptions): Promise<PaginatedQuery<Like>> {\n    let id: number\n    const clientID = await this.getClientID()\n    if (options.id) {\n      id = options.id\n    } else if (options.profileUrl) {\n      const user = await getUser(await this.prepareURL(options.profileUrl), clientID, this.axios)\n      id = user.id\n    } else if (options.nextHref) {\n      return await getLikes(options, clientID, this.axios)\n    } else {\n      throw new Error('options.id or options.profileURL must be provided.')\n    }\n    options.id = id\n\n    return getLikes(options, clientID, this.axios)\n  }\n\n  /**\n   * Returns information about a user\n   * @param url - The profile URL of the user\n   */\n  async getUser (url: string): Promise<User> {\n    return getUser(await this.prepareURL(url), await this.getClientID(), this.axios)\n  }\n\n  /**\n   * Sets the instance of Axios to use to make requests to SoundCloud API\n   * @param instance - An instance of Axios\n   */\n  setAxiosInstance (instance: AxiosInstance) {\n    this.axios = instance\n  }\n\n  /**\n   * Returns whether or not the given URL is a valid Soundcloud URL\n   * @param url - URL of the Soundcloud track\n  */\n  isValidUrl (url: string) {\n    return isValidURL(url, this.convertFirebaseLinks, this.stripMobilePrefix)\n  }\n\n  /**\n   * Returns whether or not the given URL is a valid playlist SoundCloud URL\n   * @param url - The URL to check\n   */\n  isPlaylistURL (url: string) {\n    return isPlaylistURL(url)\n  }\n\n  /**\n   * Returns true if the given URL is a personalized track URL. (of the form https://soundcloud.com/discover/sets/personalized-tracks::user-sdlkfjsldfljs:847104873)\n   * @param url - The URL to check\n   */\n  isPersonalizedTrackURL (url: string) {\n    return isPersonalizedTrackURL(url)\n  }\n\n  /**\n   * Returns true if the given URL is a Firebase URL (of the form https://soundcloud.app.goo.gl/XXXXXXXX)\n   * @param url - The URL to check\n   */\n  isFirebaseURL (url: string) {\n    return isFirebaseURL(url)\n  }\n\n  async getClientID (): Promise<string> {\n    if (!this._clientID) {\n      await this.setClientID()\n    }\n\n    return this._clientID\n  }\n\n  /** @internal */\n  async setClientID (clientID?: string): Promise<string> {\n    if (!clientID) {\n      if (!this._clientID) {\n        if (this.saveClientID) {\n          const filename = path.resolve(__dirname, this._filePath ? this._filePath : '../client_id.json')\n          const c = await this._getClientIDFromFile(filename)\n          if (!c) {\n            this._clientID = await sckey.fetchKey()\n            const data = {\n              clientID: this._clientID,\n              date: new Date().toISOString()\n            }\n            fs.writeFile(filename, JSON.stringify(data), {}, err => {\n              if (err) console.log('Failed to save client_id to file: ' + err)\n            })\n          } else {\n            this._clientID = c\n          }\n        } else {\n          this._clientID = await sckey.fetchKey()\n        }\n      }\n\n      return this._clientID\n    }\n\n    this._clientID = clientID\n\n    return clientID\n  }\n\n  /** @internal */\n  private async _getClientIDFromFile (filename: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (!fs.existsSync(filename)) return resolve('')\n\n      fs.readFile(filename, 'utf8', (err: NodeJS.ErrnoException, data: string) => {\n        if (err) return reject(err)\n        let c: ClientIDData\n        try {\n          c = JSON.parse(data)\n        } catch (err) {\n          return reject(err)\n        }\n        if (!c.date && !c.clientID) return reject(new Error(\"Property 'data' or 'clientID' missing from client_id.json\"))\n        if (typeof c.clientID !== 'string') return reject(new Error(\"Property 'clientID' is not a string in client_id.json\"))\n        if (typeof c.date !== 'string') return reject(new Error(\"Property 'date' is not a string in client_id.json\"))\n        const d = new Date(c.date)\n        if (Number.isNaN(d.getDay())) return reject(new Error(\"Invalid date object from 'date' in client_id.json\"))\n        const dayMs = 60 * 60 * 24 * 1000\n        if (new Date().getTime() - d.getTime() >= dayMs) {\n          // Older than a day, delete\n          fs.unlink(filename, err => {\n            if (err) console.log('Failed to delete client_id.json: ' + err)\n          })\n          return resolve('')\n        } else {\n          return resolve(c.clientID)\n        }\n      })\n    })\n  }\n\n  /**\n   * Prepares the given URL by stripping its mobile prefix (if this.stripMobilePrefix is true)\n   * and converting it to a regular URL (if this.convertFireBaseLinks is true.)\n   * @param url\n   */\n  async prepareURL (url: string): Promise<string> {\n    if (this.stripMobilePrefix) url = stripMobilePrefix(url)\n    if (this.convertFirebaseLinks) {\n      if (isFirebaseURL(url)) url = await convertFirebaseURL(url, this.axios)\n    }\n\n    return url\n  }\n}\n\n// SCDL instance with default configutarion\nconst scdl = new SCDL()\n\n// Creates an instance of SCDL with custom configuration\nconst create = (options: SCDLOptions): SCDL => new SCDL(options)\n\nexport { create }\n\nscdl.STREAMING_PROTOCOLS = _PROTOCOLS\nscdl.FORMATS = _FORMATS\n\nexport default scdl\n"],"mappings":"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"}