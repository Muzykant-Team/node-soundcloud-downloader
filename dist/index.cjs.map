{"version":3,"file":"index.cjs","names":["URL","url","url","url","getInfo","url","url","url","url","url","url","filterMedia","getInfo","isValidURL","sckey"],"sources":["../src/util.ts","../src/protocols.ts","../src/formats.ts","../src/info.ts","../src/filter-media.ts","../src/download.ts","../src/url.ts","../src/search.ts","../src/download-playlist.ts","../src/likes.ts","../src/user.ts","../src/index.ts"],"sourcesContent":["/** @internal @packageDocumentation */\nimport { URL } from 'url'\nimport { isAxiosError, type AxiosError } from 'axios'\n/* eslint-disable camelcase */\nexport interface PaginatedQuery<T> {\n  collection: T[],\n  total_results?: number, // is omitted if limit parameter is supplied\n  next_href: string,\n  query_urn: string\n}\nexport const resolveURL = 'https://api-v2.soundcloud.com/resolve'\nexport const handleRequestErrs = (err: unknown): Error => {\n  // Obsługa błędów nie-Axios\n  if (!isAxiosError(err)) {\n    if (err instanceof Error) {\n      return err;\n    }\n    return new Error('Unknown error occurred', { cause: err });\n  }\n  const axiosErr = err as AxiosError;\n\n  // Brak odpowiedzi - problemy sieciowe\n  if (!axiosErr.response) {\n    // Obsługa obu kodów timeout: ECONNABORTED i ETIMEDOUT\n    const code = axiosErr.code;\n    const message = code === 'ECONNABORTED' || code === 'ETIMEDOUT'\n      ? 'Request timeout. Please check your connection.'\n      : code === 'ERR_NETWORK'\n        ? 'Network error. Please check your internet connection.'\n        : code === 'ERR_CANCELED'\n          ? 'Request was canceled.'\n          : 'Request failed. Please try again.';\n    return new Error(message, { cause: axiosErr });\n  }\n  const status = axiosErr.response.status;\n  let descriptiveMessage: string;\n  switch (status) {\n    case 400:\n      descriptiveMessage = 'Bad request. Please check the parameters.';\n      break;\n    case 401:\n      descriptiveMessage = 'Authentication failed. Is your Client ID correct?';\n      break;\n    case 403:\n      descriptiveMessage = 'Access forbidden. You may not have permission to access this resource.';\n      break;\n    case 404:\n      descriptiveMessage = 'Resource not found. It may be private or the URL is incorrect.';\n      break;\n    case 429:\n      descriptiveMessage = 'Rate limit exceeded. Please wait before making more requests.';\n      break;\n    case 500:\n    case 502:\n    case 503:\n    case 504:\n      descriptiveMessage = 'SoundCloud server error. Please try again later.';\n      break;\n    default:\n      descriptiveMessage = `Request failed with status ${status}: ${axiosErr.message}`;\n  }\n  return new Error(descriptiveMessage, { cause: axiosErr });\n}\nexport const appendURL = (url: string, ...params: string[]): string => {\n  try {\n    const u = new URL(url);\n\n    // Walidacja: params musi być parzystej długości\n    if (params.length % 2 !== 0) {\n      throw new Error(\n        `Parameters must be provided in key-value pairs. Received ${params.length} parameters.`\n      );\n    }\n    for (let idx = 0; idx < params.length; idx += 2) {\n      const key = params[idx];\n      const value = params[idx + 1];\n\n      if (key && value !== undefined && value !== null) {\n        u.searchParams.append(key, value);\n      }\n    }\n\n    return u.href;\n  } catch (err) {\n    if (err instanceof TypeError) {\n      throw new Error(`Invalid URL: ${url}`, { cause: err });\n    }\n    throw err;\n  }\n}\nexport const extractIDFromPersonalizedTrackURL = (url: string): string => {\n  if (!url || typeof url !== 'string') return '';\n  if (!url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) return '';\n\n  const colonIndex = url.lastIndexOf(':');\n  if (colonIndex === -1) return '';\n\n  return url.slice(colonIndex + 1);\n}\nexport const kindMismatchError = (expected: string, received: string): Error =>\n  new Error(`Expected resource of kind: (${expected}), received: (${received})`);\n","/**\n * Soundcloud streams tracks using these protocols.\n */\nenum STREAMING_PROTOCOLS {\n  HLS = 'hls',\n  PROGRESSIVE = 'progressive'\n}\n\n/** @internal */\nexport const _PROTOCOLS = {\n  HLS: STREAMING_PROTOCOLS.HLS,\n  PROGRESSIVE: STREAMING_PROTOCOLS.PROGRESSIVE\n}\n\nexport default STREAMING_PROTOCOLS\n","/**\n * Complete Audio Format Support for SoundCloud\n * \n * Formats are organized from HIGHEST to LOWEST quality:\n * 1. Lossless (FLAC, WAV, AIFF, ALAC, DSD)\n * 2. High-Res/Premium (256kbps+)\n * 3. Standard (128-192kbps)\n * 4. Low/Preview (64-96kbps)\n * 5. Legacy/Deprecated\n * \n * @module formats\n */\n\n// ============================================================================\n// QUALITY TIERS\n// ============================================================================\n\n/** SoundCloud quality tiers (highest to lowest) */\nexport enum QUALITY_TIER {\n  /** Lossless - FLAC, WAV, AIFF, ALAC */\n  LOSSLESS = 'lossless',\n  /** Go+ Premium - 256kbps AAC */\n  PREMIUM = 'premium',\n  /** High quality - 192kbps */\n  HIGH = 'high',\n  /** Standard quality - 160kbps (default) */\n  STANDARD = 'standard',\n  /** Low quality - 128kbps */\n  LOW = 'low',\n  /** Preview/Ultra low - 64-96kbps */\n  PREVIEW = 'preview',\n}\n\n// ============================================================================\n// AUDIO FORMATS (Ordered from BEST to WORST quality)\n// ============================================================================\n\n/**\n * All audio formats supported by SoundCloud.\n * \n * **Order: Best quality → Worst quality**\n */\nexport enum FORMATS {\n  // ==========================================================================\n  // 1. LOSSLESS FORMATS (Best Quality - No compression loss)\n  // ==========================================================================\n\n  /** DSD 512 - Direct Stream Digital (highest) */\n  DSD_512 = 'audio/dsd',\n  /** DSD 256 */\n  DSD_256 = 'audio/dsd',\n  /** DSD 128 */\n  DSD_128 = 'audio/dsd',\n  /** DSD 64 - Standard DSD */\n  DSD_64 = 'audio/dsd',\n  /** DSD generic */\n  DSD = 'audio/dsd',\n\n  /** MQA - Master Quality Authenticated */\n  MQA = 'audio/mqa',\n\n  /** FLAC 32-bit/384kHz Hi-Res */\n  FLAC_32_384 = 'audio/flac',\n  /** FLAC 24-bit/192kHz Hi-Res */\n  FLAC_24_192 = 'audio/flac',\n  /** FLAC 24-bit/96kHz Hi-Res */\n  FLAC_24_96 = 'audio/flac',\n  /** FLAC 24-bit/48kHz Hi-Res */\n  FLAC_24_48 = 'audio/flac',\n  /** FLAC 24-bit generic */\n  FLAC_24 = 'audio/flac',\n  /** FLAC 16-bit CD quality */\n  FLAC_16 = 'audio/flac',\n  /** FLAC generic */\n  FLAC = 'audio/flac',\n\n  /** WAV 32-bit float */\n  WAV_32F = 'audio/wav',\n  /** WAV 32-bit integer */\n  WAV_32 = 'audio/wav',\n  /** WAV 24-bit */\n  WAV_24 = 'audio/wav',\n  /** WAV 16-bit CD quality */\n  WAV_16 = 'audio/wav',\n  /** WAV generic */\n  WAV = 'audio/wav',\n\n  /** AIFF 24-bit */\n  AIFF_24 = 'audio/aiff',\n  /** AIFF 16-bit */\n  AIFF_16 = 'audio/aiff',\n  /** AIFF generic */\n  AIFF = 'audio/aiff',\n\n  /** Apple Lossless 24-bit */\n  ALAC_24 = 'audio/alac',\n  /** Apple Lossless 16-bit */\n  ALAC_16 = 'audio/alac',\n  /** Apple Lossless generic */\n  ALAC = 'audio/alac',\n\n  /** WMA Lossless */\n  WMA_LOSSLESS = 'audio/x-ms-wma',\n\n  /** Monkey's Audio (APE) */\n  APE = 'audio/ape',\n  /** True Audio (TTA) */\n  TTA = 'audio/tta',\n  /** WavPack */\n  WAVPACK = 'audio/wavpack',\n  /** WavPack Hybrid (lossy+correction) */\n  WAVPACK_HYBRID = 'audio/wavpack',\n  /** Musepack / MPC */\n  MUSEPACK = 'audio/musepack',\n  /** OptimFROG */\n  OPTIMFROG = 'audio/ofr',\n  /** Shorten */\n  SHORTEN = 'audio/shn',\n  /** TAK (Tom's Audio Kompressor) */\n  TAK = 'audio/tak',\n  /** LA (Lossless Audio) */\n  LA = 'audio/la',\n  /** ATRAC Advanced Lossless */\n  ATRAC_AL = 'audio/atrac-al',\n  /** FLAC in Matroska container */\n  MKA_FLAC = 'audio/x-matroska',\n\n  // --------------------------------------------------------------------------\n  // HLS/Streaming Lossless\n  // --------------------------------------------------------------------------\n\n  /** HLS ALAC (Apple Lossless over HLS) */\n  HLS_ALAC = 'application/vnd.apple.mpegurl',\n  /** HLS FLAC */\n  HLS_FLAC = 'application/vnd.apple.mpegurl',\n  /** HLS PCM */\n  HLS_PCM = 'application/vnd.apple.mpegurl',\n  /** DASH FLAC */\n  DASH_FLAC = 'application/dash+xml',\n  /** DASH ALAC */\n  DASH_ALAC = 'application/dash+xml',\n\n  // ==========================================================================\n  // 2. HIGH BITRATE LOSSY (Premium Quality - 256kbps+)\n  // ==========================================================================\n\n  /** AAC 320kbps (if available) */\n  AAC_320 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n  /** AAC 256kbps - Go+ Premium */\n  AAC_256 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n\n  /** MP3 320kbps - Highest MP3 */\n  MP3_320 = 'audio/mpeg',\n  /** MP3 256kbps */\n  MP3_256 = 'audio/mpeg',\n\n  /** Ogg Vorbis 500kbps */\n  OGG_VORBIS_500 = 'audio/ogg; codecs=\"vorbis\"',\n  /** Ogg Vorbis 320kbps */\n  OGG_VORBIS_320 = 'audio/ogg; codecs=\"vorbis\"',\n\n  /** Opus 256kbps */\n  OPUS_256 = 'audio/ogg; codecs=\"opus\"',\n\n  // --------------------------------------------------------------------------\n  // HLS/DASH High Bitrate AAC\n  // --------------------------------------------------------------------------\n\n  /** HLS AAC 320kbps */\n  HLS_AAC_320 = 'application/vnd.apple.mpegurl',\n  /** HLS AAC 256kbps - Go+ Premium streaming */\n  HLS_AAC_256 = 'application/vnd.apple.mpegurl',\n  /** DASH AAC 320kbps */\n  DASH_AAC_320 = 'application/dash+xml',\n  /** DASH AAC 256kbps */\n  DASH_AAC_256 = 'application/dash+xml',\n\n  // ==========================================================================\n  // 3. STANDARD BITRATE (Good Quality - 160-224kbps)\n  // ==========================================================================\n\n  /** AAC 224kbps */\n  AAC_224 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n  /** AAC 192kbps */\n  AAC_192 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n  /** AAC 160kbps - Default SoundCloud HLS */\n  AAC_160 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n\n  /** MP3 224kbps */\n  MP3_224 = 'audio/mpeg',\n  /** MP3 192kbps */\n  MP3_192 = 'audio/mpeg',\n  /** MP3 160kbps */\n  MP3_160 = 'audio/mpeg',\n\n  /** Ogg Vorbis 192kbps */\n  OGG_VORBIS_192 = 'audio/ogg; codecs=\"vorbis\"',\n  /** Ogg Vorbis 160kbps */\n  OGG_VORBIS_160 = 'audio/ogg; codecs=\"vorbis\"',\n\n  /** Opus 160kbps */\n  OPUS_160 = 'audio/ogg; codecs=\"opus\"',\n\n  /** HLS AAC 192kbps */\n  HLS_AAC_192 = 'application/vnd.apple.mpegurl',\n  /** HLS AAC 160kbps - SoundCloud default */\n  HLS_AAC_160 = 'application/vnd.apple.mpegurl',\n  /** DASH AAC 192kbps */\n  DASH_AAC_192 = 'application/dash+xml',\n  /** DASH AAC 160kbps */\n  DASH_AAC_160 = 'application/dash+xml',\n\n  // ==========================================================================\n  // 4. LOW BITRATE (Standard Quality - 96-128kbps)\n  // ==========================================================================\n\n  /** AAC 128kbps */\n  AAC_128 = 'audio/mp4; codecs=\"mp4a.40.2\"',\n  /** AAC 96kbps - HLS fallback */\n  AAC_96 = 'audio/mp4; codecs=\"mp4a.40.5\"',\n\n  /** MP3 128kbps - Legacy free tier */\n  MP3_128 = 'audio/mpeg',\n  /** MP3 112kbps */\n  MP3_112 = 'audio/mpeg',\n  /** MP3 96kbps */\n  MP3_96 = 'audio/mpeg',\n\n  /** Opus 128kbps */\n  OPUS_128 = 'audio/ogg; codecs=\"opus\"',\n  /** Opus 96kbps */\n  OPUS_96 = 'audio/ogg; codecs=\"opus\"',\n\n  /** Ogg Vorbis 128kbps */\n  OGG_VORBIS_128 = 'audio/ogg; codecs=\"vorbis\"',\n  /** Ogg Vorbis 96kbps */\n  OGG_VORBIS_96 = 'audio/ogg; codecs=\"vorbis\"',\n\n  /** HLS AAC 128kbps */\n  HLS_AAC_128 = 'application/vnd.apple.mpegurl',\n  /** HLS AAC 96kbps - SoundCloud fallback */\n  HLS_AAC_96 = 'application/vnd.apple.mpegurl',\n  /** DASH AAC 128kbps */\n  DASH_AAC_128 = 'application/dash+xml',\n  /** DASH AAC 96kbps */\n  DASH_AAC_96 = 'application/dash+xml',\n\n  // ==========================================================================\n  // 5. PREVIEW / ULTRA LOW BITRATE (32-64kbps)\n  // ==========================================================================\n\n  /** AAC 64kbps - Low bandwidth */\n  AAC_64 = 'audio/mp4; codecs=\"mp4a.40.29\"',\n  /** AAC 48kbps - Ultra low */\n  AAC_48 = 'audio/mp4; codecs=\"mp4a.40.29\"',\n  /** AAC 32kbps - Minimum */\n  AAC_32 = 'audio/mp4; codecs=\"mp4a.40.29\"',\n\n  /** MP3 64kbps */\n  MP3_64 = 'audio/mpeg',\n  /** MP3 48kbps */\n  MP3_48 = 'audio/mpeg',\n  /** MP3 32kbps */\n  MP3_32 = 'audio/mpeg',\n\n  /** Opus 64kbps - Legacy low bandwidth */\n  OPUS_64 = 'audio/ogg; codecs=\"opus\"',\n  /** Opus 48kbps */\n  OPUS_48 = 'audio/ogg; codecs=\"opus\"',\n  /** Opus 32kbps */\n  OPUS_32 = 'audio/ogg; codecs=\"opus\"',\n\n  /** HLS AAC 64kbps */\n  HLS_AAC_64 = 'application/vnd.apple.mpegurl',\n  /** HLS AAC 48kbps */\n  HLS_AAC_48 = 'application/vnd.apple.mpegurl',\n  /** DASH AAC 64kbps */\n  DASH_AAC_64 = 'application/dash+xml',\n  /** DASH AAC 48kbps */\n  DASH_AAC_48 = 'application/dash+xml',\n\n  /** MP3 Preview */\n  MP3_PREVIEW = 'audio/mpeg',\n\n  // ==========================================================================\n  // 6. GENERIC / CONTAINER FORMATS\n  // ==========================================================================\n\n  /** AAC generic (default profile) */\n  AAC = 'audio/mp4; codecs=\"mp4a.40.2\"',\n  /** AAC-LC (Low Complexity) */\n  AAC_LC = 'audio/aac',\n  /** AAC-HE v1 (SBR) */\n  AAC_HE = 'audio/mp4; codecs=\"mp4a.40.5\"',\n  /** AAC-HE v2 (SBR + PS) */\n  AAC_HE_V2 = 'audio/mp4; codecs=\"mp4a.40.29\"',\n  /** xHE-AAC (Extended HE-AAC) */\n  AAC_XHE = 'audio/mp4; codecs=\"mp4a.40.42\"',\n\n  /** MP3 generic */\n  MP3 = 'audio/mpeg',\n  /** MP2 (MPEG Layer II) */\n  MP2 = 'audio/mpeg',\n  /** MP1 (MPEG Layer I) */\n  MP1 = 'audio/mpeg',\n\n  /** Opus generic */\n  OPUS = 'audio/ogg; codecs=\"opus\"',\n  /** Opus in WebM container */\n  WEBM_OPUS = 'audio/webm; codecs=\"opus\"',\n\n  /** Ogg Vorbis generic */\n  OGG_VORBIS = 'audio/ogg; codecs=\"vorbis\"',\n  /** Ogg generic */\n  OGG = 'audio/ogg',\n\n  /** M4A container */\n  M4A = 'audio/mp4',\n  /** MP4 audio */\n  MP4_AUDIO = 'audio/mp4',\n\n  // ==========================================================================\n  // 7. SURROUND / MULTICHANNEL\n  // ==========================================================================\n\n  /** Dolby Digital (AC-3) */\n  AC3 = 'audio/ac3',\n  /** Dolby Digital Plus (E-AC-3) */\n  EAC3 = 'audio/eac3',\n  /** Dolby Atmos */\n  DOLBY_ATMOS = 'audio/eac3-joc',\n  /** DTS */\n  DTS = 'audio/vnd.dts',\n  /** DTS-HD */\n  DTS_HD = 'audio/vnd.dts.hd',\n  /** DTS:X */\n  DTS_X = 'audio/vnd.dts.uhd',\n\n  // ==========================================================================\n  // 8. MOBILE / VOICE FORMATS\n  // ==========================================================================\n\n  /** AMR Narrowband */\n  AMR_NB = 'audio/amr',\n  /** AMR Wideband */\n  AMR_WB = 'audio/amr-wb',\n  /** AMR generic */\n  AMR = 'audio/amr',\n\n  /** 3GPP audio */\n  THREE_GPP = 'audio/3gpp',\n  /** 3GPP2 audio */\n  THREE_GPP2 = 'audio/3gpp2',\n\n  /** GSM */\n  GSM = 'audio/gsm',\n  /** G.711 μ-law */\n  G711_ULAW = 'audio/basic',\n  /** G.711 A-law */\n  G711_ALAW = 'audio/x-alaw-basic',\n\n  // ==========================================================================\n  // 9. LEGACY / OTHER FORMATS\n  // ==========================================================================\n\n  /** Windows Media Audio */\n  WMA = 'audio/x-ms-wma',\n  /** WMA Pro */\n  WMA_PRO = 'audio/x-ms-wma',\n  /** WMA Voice */\n  WMA_VOICE = 'audio/x-ms-wma',\n\n  /** RealAudio */\n  REAL_AUDIO = 'audio/vnd.rn-realaudio',\n\n  /** Apple CAF */\n  CAF = 'audio/x-caf',\n  /** AU / SND (Sun/NeXT) */\n  AU = 'audio/basic',\n  SND = 'audio/basic',\n\n  /** RAW PCM */\n  PCM_RAW = 'audio/L16',\n  /** PCM signed 16-bit */\n  PCM_S16LE = 'audio/L16',\n  /** PCM signed 24-bit */\n  PCM_S24LE = 'audio/L24',\n  /** PCM float 32-bit */\n  PCM_F32LE = 'audio/L32',\n\n  /** MIDI */\n  MIDI = 'audio/midi',\n  /** MIDI Standard */\n  MID = 'audio/midi',\n\n  /** Speex */\n  SPEEX = 'audio/ogg; codecs=\"speex\"',\n\n  /** AC4 */\n  AC4 = 'audio/ac4',\n\n  /** MPEG-H Audio */\n  MPEGH = 'audio/mhas',\n\n  // ==========================================================================\n  // 11. SONY / PLAYSTATION FORMATS\n  // ==========================================================================\n\n  /** Sony ATRAC */\n  ATRAC = 'audio/atrac',\n  /** ATRAC3 */\n  ATRAC3 = 'audio/atrac3',\n  /** ATRAC3+ */\n  ATRAC3_PLUS = 'audio/atrac3plus',\n  /** ATRAC9 */\n  ATRAC9 = 'audio/atrac9',\n\n  // ==========================================================================\n  // 12. GAME / MULTIMEDIA FORMATS\n  // ==========================================================================\n\n  /** XMA (Xbox Media Audio) */\n  XMA = 'audio/xma',\n  /** XMA2 */\n  XMA2 = 'audio/xma2',\n  /** BINK Audio */\n  BINK = 'audio/bink',\n  /** Vorbis in Matroska */\n  MKA_VORBIS = 'audio/x-matroska',\n  /** Generic Matroska Audio */\n  MKA = 'audio/x-matroska',\n\n  // ==========================================================================\n  // 13. FUTURE / EXPERIMENTAL CODECS\n  // ==========================================================================\n\n  /** AV1 Audio (experimental) */\n  AV1_AUDIO = 'audio/av1',\n  /** USAC (Unified Speech and Audio Coding) */\n  USAC = 'audio/usac',\n  /** EVS (Enhanced Voice Services) */\n  EVS = 'audio/evs',\n  /** LC3 (Low Complexity Communication Codec) */\n  LC3 = 'audio/lc3',\n  /** LC3plus */\n  LC3_PLUS = 'audio/lc3plus',\n  /** Lyra (Google) */\n  LYRA = 'audio/lyra',\n  /** Satin (Google) */\n  SATIN = 'audio/satin',\n  /** Encodec (Meta) */\n  ENCODEC = 'audio/encodec',\n  /** SoundStream */\n  SOUNDSTREAM = 'audio/soundstream',\n\n  // ==========================================================================\n  // 14. STREAMING SPECIFIC\n  // ==========================================================================\n\n  /** HLS Audio AAC */\n  HLS_AAC = 'application/vnd.apple.mpegurl',\n  /** HLS Audio fMP4 */\n  HLS_FMP4 = 'application/vnd.apple.mpegurl',\n  /** DASH Audio */\n  DASH = 'application/dash+xml',\n  /** Smooth Streaming Audio */\n  SMOOTH = 'application/vnd.ms-sstr+xml',\n}\n\n// ============================================================================\n// FORMAT PRIORITY (Ordered best to worst for automatic selection)\n// ============================================================================\n\n/** Ordered list of formats from BEST to WORST for automatic selection */\nexport const FORMAT_PRIORITY: FORMATS[] = [\n  // ========== 1. LOSSLESS (Best Quality) ==========\n  // DSD (highest resolution)\n  FORMATS.DSD_512, FORMATS.DSD_256, FORMATS.DSD_128, FORMATS.DSD_64, FORMATS.DSD,\n  // MQA\n  FORMATS.MQA,\n  // FLAC (by bit depth and sample rate)\n  FORMATS.FLAC_32_384, FORMATS.FLAC_24_192, FORMATS.FLAC_24_96, FORMATS.FLAC_24_48, FORMATS.FLAC_24, FORMATS.FLAC_16, FORMATS.FLAC,\n  // WAV\n  FORMATS.WAV_32F, FORMATS.WAV_32, FORMATS.WAV_24, FORMATS.WAV_16, FORMATS.WAV,\n  // AIFF\n  FORMATS.AIFF_24, FORMATS.AIFF_16, FORMATS.AIFF,\n  // ALAC\n  FORMATS.ALAC_24, FORMATS.ALAC_16, FORMATS.ALAC,\n  // Other lossless\n  FORMATS.WMA_LOSSLESS, FORMATS.APE, FORMATS.TTA, FORMATS.WAVPACK, FORMATS.WAVPACK_HYBRID,\n  FORMATS.MUSEPACK, FORMATS.OPTIMFROG, FORMATS.SHORTEN, FORMATS.TAK, FORMATS.LA,\n  FORMATS.ATRAC_AL, FORMATS.MKA_FLAC,\n  // HLS/DASH Lossless\n  FORMATS.HLS_ALAC, FORMATS.HLS_FLAC, FORMATS.HLS_PCM, FORMATS.DASH_FLAC, FORMATS.DASH_ALAC,\n\n  // ========== 2. HIGH BITRATE (256kbps+) ==========\n  FORMATS.AAC_320, FORMATS.AAC_256,\n  FORMATS.MP3_320, FORMATS.MP3_256,\n  FORMATS.OGG_VORBIS_500, FORMATS.OGG_VORBIS_320,\n  FORMATS.OPUS_256,\n  // HLS/DASH High Bitrate\n  FORMATS.HLS_AAC_320, FORMATS.HLS_AAC_256, FORMATS.DASH_AAC_320, FORMATS.DASH_AAC_256,\n\n  // ========== 3. STANDARD QUALITY (160-224kbps) ==========\n  FORMATS.AAC_224, FORMATS.AAC_192, FORMATS.AAC_160,\n  FORMATS.MP3_224, FORMATS.MP3_192, FORMATS.MP3_160,\n  FORMATS.OGG_VORBIS_192, FORMATS.OGG_VORBIS_160,\n  FORMATS.OPUS_160,\n  // HLS/DASH Standard\n  FORMATS.HLS_AAC_192, FORMATS.HLS_AAC_160, FORMATS.DASH_AAC_192, FORMATS.DASH_AAC_160,\n\n  // ========== 4. LOW QUALITY (96-128kbps) ==========\n  FORMATS.AAC_128, FORMATS.AAC_96,\n  FORMATS.MP3_128, FORMATS.MP3_112, FORMATS.MP3_96,\n  FORMATS.OPUS_128, FORMATS.OPUS_96,\n  FORMATS.OGG_VORBIS_128, FORMATS.OGG_VORBIS_96,\n  // HLS/DASH Low\n  FORMATS.HLS_AAC_128, FORMATS.HLS_AAC_96, FORMATS.DASH_AAC_128, FORMATS.DASH_AAC_96,\n\n  // ========== 5. PREVIEW / ULTRA LOW (32-64kbps) ==========\n  FORMATS.AAC_64, FORMATS.AAC_48, FORMATS.AAC_32,\n  FORMATS.MP3_64, FORMATS.MP3_48, FORMATS.MP3_32,\n  FORMATS.OPUS_64, FORMATS.OPUS_48, FORMATS.OPUS_32,\n  FORMATS.MP3_PREVIEW,\n  // HLS/DASH Preview\n  FORMATS.HLS_AAC_64, FORMATS.HLS_AAC_48, FORMATS.DASH_AAC_64, FORMATS.DASH_AAC_48,\n\n  // ========== 6. GENERIC FORMATS ==========\n  FORMATS.AAC, FORMATS.AAC_LC, FORMATS.AAC_HE, FORMATS.AAC_HE_V2, FORMATS.AAC_XHE,\n  FORMATS.MP3, FORMATS.OPUS, FORMATS.WEBM_OPUS,\n  FORMATS.OGG_VORBIS, FORMATS.OGG,\n  FORMATS.M4A, FORMATS.MP4_AUDIO,\n\n  // ========== 7. SURROUND / MULTICHANNEL ==========\n  FORMATS.DOLBY_ATMOS, FORMATS.EAC3, FORMATS.AC3,\n  FORMATS.DTS_X, FORMATS.DTS_HD, FORMATS.DTS,\n\n  // ========== 8. SONY / GAME FORMATS ==========\n  FORMATS.ATRAC9, FORMATS.ATRAC3_PLUS, FORMATS.ATRAC3, FORMATS.ATRAC,\n  FORMATS.XMA2, FORMATS.XMA, FORMATS.BINK,\n\n  // ========== 9. FUTURE / EXPERIMENTAL ==========\n  FORMATS.MPEGH, FORMATS.USAC, FORMATS.AC4,\n  FORMATS.LC3_PLUS, FORMATS.LC3, FORMATS.EVS,\n  FORMATS.LYRA, FORMATS.SATIN, FORMATS.ENCODEC, FORMATS.SOUNDSTREAM, FORMATS.AV1_AUDIO,\n\n  // ========== 10. STREAMING ==========\n  FORMATS.HLS_AAC, FORMATS.HLS_FMP4, FORMATS.DASH, FORMATS.SMOOTH,\n\n  // ========== 11. VOICE / MOBILE ==========\n  FORMATS.AMR_WB, FORMATS.AMR_NB, FORMATS.AMR,\n  FORMATS.EVS, FORMATS.GSM,\n  FORMATS.G711_ULAW, FORMATS.G711_ALAW,\n  FORMATS.THREE_GPP, FORMATS.THREE_GPP2,\n\n  // ========== 12. LEGACY / OTHER ==========\n  FORMATS.MP2, FORMATS.MP1,\n  FORMATS.WMA_PRO, FORMATS.WMA_VOICE, FORMATS.WMA,\n  FORMATS.REAL_AUDIO, FORMATS.SPEEX,\n  FORMATS.CAF, FORMATS.MKA, FORMATS.MKA_VORBIS,\n  FORMATS.AU, FORMATS.SND,\n  FORMATS.PCM_F32LE, FORMATS.PCM_S24LE, FORMATS.PCM_S16LE, FORMATS.PCM_RAW,\n  FORMATS.MIDI, FORMATS.MID,\n];\n\n// ============================================================================\n// INTERNAL FORMAT MAP\n// ============================================================================\n\n/** @internal */\nexport const _FORMATS = Object.fromEntries(\n  Object.entries(FORMATS).map(([key, value]) => [key, value])\n) as Record<keyof typeof FORMATS, FORMATS>;\n\n// ============================================================================\n// FORMAT SETS (for quick lookups)\n// ============================================================================\n\nconst LOSSLESS_SET = new Set<FORMATS>([\n  FORMATS.DSD_512, FORMATS.DSD_256, FORMATS.DSD_128, FORMATS.DSD_64, FORMATS.DSD,\n  FORMATS.MQA,\n  FORMATS.FLAC_32_384, FORMATS.FLAC_24_192, FORMATS.FLAC_24_96, FORMATS.FLAC_24_48, FORMATS.FLAC_24, FORMATS.FLAC_16, FORMATS.FLAC,\n  FORMATS.WAV_32F, FORMATS.WAV_32, FORMATS.WAV_24, FORMATS.WAV_16, FORMATS.WAV,\n  FORMATS.AIFF_24, FORMATS.AIFF_16, FORMATS.AIFF,\n  FORMATS.ALAC_24, FORMATS.ALAC_16, FORMATS.ALAC,\n  FORMATS.WMA_LOSSLESS,\n]);\n\nconst AAC_SET = new Set<FORMATS>([\n  FORMATS.AAC_320, FORMATS.AAC_256, FORMATS.AAC_224, FORMATS.AAC_192, FORMATS.AAC_160,\n  FORMATS.AAC_128, FORMATS.AAC_96, FORMATS.AAC_64, FORMATS.AAC_48, FORMATS.AAC_32,\n  FORMATS.AAC, FORMATS.AAC_LC, FORMATS.AAC_HE, FORMATS.AAC_HE_V2, FORMATS.AAC_XHE, FORMATS.M4A,\n]);\n\nconst PREMIUM_SET = new Set<FORMATS>([\n  ...LOSSLESS_SET,\n  FORMATS.AAC_320, FORMATS.AAC_256,\n  FORMATS.MP3_320, FORMATS.MP3_256,\n]);\n\nconst DEPRECATED_SET = new Set<FORMATS>([\n  FORMATS.OPUS, FORMATS.OPUS_256, FORMATS.OPUS_160, FORMATS.OPUS_128, FORMATS.OPUS_96, FORMATS.OPUS_64, FORMATS.OPUS_48, FORMATS.OPUS_32,\n  FORMATS.WEBM_OPUS,\n  FORMATS.OGG_VORBIS, FORMATS.OGG_VORBIS_500, FORMATS.OGG_VORBIS_320, FORMATS.OGG_VORBIS_192, FORMATS.OGG_VORBIS_160, FORMATS.OGG_VORBIS_128, FORMATS.OGG_VORBIS_96,\n]);\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/** Check if format is lossless */\nexport const isLosslessFormat = (format: FORMATS): boolean => LOSSLESS_SET.has(format);\n\n/** Check if format is AAC-based (recommended 2026+) */\nexport const isAACFormat = (format: FORMATS): boolean => AAC_SET.has(format);\n\n/** Check if format requires Go+ Premium */\nexport const isPremiumFormat = (format: FORMATS): boolean => PREMIUM_SET.has(format);\n\n/** Check if format is deprecated for HLS (Dec 2025) */\nexport const isDeprecatedFormat = (format: FORMATS): boolean => DEPRECATED_SET.has(format);\n\n/** Get recommended format for quality tier */\nexport const getFormatForTier = (tier: QUALITY_TIER): FORMATS => {\n  switch (tier) {\n    case QUALITY_TIER.LOSSLESS: return FORMATS.FLAC;\n    case QUALITY_TIER.PREMIUM: return FORMATS.AAC_256;\n    case QUALITY_TIER.HIGH: return FORMATS.AAC_192;\n    case QUALITY_TIER.STANDARD: return FORMATS.AAC_160;\n    case QUALITY_TIER.LOW: return FORMATS.AAC_128;\n    case QUALITY_TIER.PREVIEW: return FORMATS.AAC_64;\n    default: return FORMATS.AAC_160;\n  }\n};\n\n/** Get bitrate in kbps (0 if unknown/lossless) */\nexport const getFormatBitrate = (format: FORMATS): number => {\n  const formatStr = String(format);\n  const match = formatStr.match(/(\\d+)$/);\n  if (match?.[1]) {\n    const num = parseInt(match[1], 10);\n    // Filter out codec numbers and sample rates\n    if (num <= 512 && num !== 40 && num !== 42 && num !== 29 && num !== 5 && num !== 2) {\n      return num;\n    }\n  }\n  // Special cases\n  switch (format) {\n    case FORMATS.AAC_320: case FORMATS.MP3_320: case FORMATS.OGG_VORBIS_320: return 320;\n    case FORMATS.AAC_256: case FORMATS.MP3_256: case FORMATS.OPUS_256: return 256;\n    case FORMATS.AAC_224: case FORMATS.MP3_224: return 224;\n    case FORMATS.AAC_192: case FORMATS.MP3_192: case FORMATS.OGG_VORBIS_192: return 192;\n    case FORMATS.AAC_160: case FORMATS.MP3_160: case FORMATS.OGG_VORBIS_160: case FORMATS.OPUS_160: return 160;\n    case FORMATS.AAC_128: case FORMATS.MP3_128: case FORMATS.OPUS_128: case FORMATS.OGG_VORBIS_128: return 128;\n    case FORMATS.AAC_96: case FORMATS.MP3_96: case FORMATS.OPUS_96: case FORMATS.OGG_VORBIS_96: return 96;\n    case FORMATS.AAC_64: case FORMATS.MP3_64: case FORMATS.OPUS_64: return 64;\n    case FORMATS.AAC_48: case FORMATS.MP3_48: case FORMATS.OPUS_48: return 48;\n    case FORMATS.AAC_32: case FORMATS.MP3_32: case FORMATS.OPUS_32: return 32;\n    default: return 0; // Unknown or lossless\n  }\n};\n\n/** Get best available format from a list of available formats */\nexport const getBestFormat = (available: FORMATS[]): FORMATS | undefined => {\n  for (const format of FORMAT_PRIORITY) {\n    if (available.includes(format)) {\n      return format;\n    }\n  }\n  return available[0];\n};\n\n/** Compare two formats (for sorting, negative = first is better) */\nexport const compareFormats = (a: FORMATS, b: FORMATS): number => {\n  const indexA = FORMAT_PRIORITY.indexOf(a);\n  const indexB = FORMAT_PRIORITY.indexOf(b);\n  const posA = indexA === -1 ? FORMAT_PRIORITY.length : indexA;\n  const posB = indexB === -1 ? FORMAT_PRIORITY.length : indexB;\n  return posA - posB;\n};\n\nexport default FORMATS;\n","/* eslint-disable camelcase */\nimport type { AxiosInstance } from 'axios'\nimport { handleRequestErrs, appendURL, extractIDFromPersonalizedTrackURL } from './util'\nimport STREAMING_PROTOCOLS from './protocols'\nimport FORMATS from './formats'\n\n/**\n * A Soundcloud user\n */\nexport interface User {\n  kind: string,\n  avatar_url: string,\n  city: string,\n  comments_count: number,\n  country_code: string,\n  created_at: string,\n  description: string,\n  followers_count: number,\n  followings_count: number,\n  first_name: string,\n  full_name: string,\n  groups_count: number,\n  id: number,\n  last_name: string,\n  permalink_url: string,\n  uri: string,\n  username: string\n}\n\n/**\n * Details about the track\n */\nexport interface TrackInfo {\n  kind: string\n  monetization_model: string,\n  id: number,\n  policy: string,\n  comment_count?: number,\n  full_duration?: number,\n  downloadable?: false,\n  created_at?: string,\n  description?: string,\n  media?: { transcodings: Transcoding[] },\n  title?: string,\n  publisher_metadata?: any,\n  duration?: number,\n  has_downloads_left?: boolean,\n  artwork_url?: string,\n  public?: boolean,\n  streamable?: true,\n  tag_list?: string,\n  genre?: string,\n  reposts_count?: number,\n  label_name?: string,\n  state?: string,\n  last_modified?: string,\n  commentable?: boolean,\n  uri?: string,\n  download_count?: number,\n  likes_count?: number,\n  display_date?: string,\n  user_id?: number,\n  waveform_url?: string,\n  permalink?: string,\n  permalink_url?: string,\n  user?: User,\n  playback_count?: number\n}\n\n/**\n * Details about a Set\n */\nexport interface SetInfo {\n  duration: number,\n  permalink_url: string,\n  reposts_count: number,\n  genre: string,\n  permalink: string,\n  purchase_url?: string,\n  description?: string,\n  uri: string,\n  label_name?: string,\n  tag_list: string,\n  set_type: string,\n  public: boolean,\n  track_count: number,\n  user_id: number,\n  last_modified: string,\n  license: string,\n  tracks: TrackInfo[],\n  id: number,\n  release_date?: string,\n  display_date: string,\n  sharing: string,\n  secret_token?: string,\n  created_at: string,\n  likes_count: number,\n  kind: string,\n  purchase_title?: string,\n  managed_by_feeds: boolean,\n  artwork_url?: string,\n  is_album: boolean,\n  user: User,\n  published_at: string,\n  embeddable_by: string\n}\n\n/**\n * Represents an audio link to a Soundcloud Track\n */\nexport interface Transcoding {\n  url: string,\n  preset: string,\n  snipped: boolean,\n  format: { protocol: STREAMING_PROTOCOLS, mime_type: FORMATS }\n}\n\nconst getTrackInfoBase = async (clientID: string, axiosRef: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string): Promise<TrackInfo[]> => {\n  let url = appendURL('https://api-v2.soundcloud.com/tracks', 'ids', ids.join(','), 'client_id', clientID)\n  if (playlistID && playlistSecretToken) {\n    url = appendURL(url, 'playlistId', String(playlistID), 'playlistSecretToken', playlistSecretToken)\n  }\n  try {\n    const { data } = await axiosRef.get(url)\n\n    return data as TrackInfo[]\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\n/** @internal */\nexport const getInfoBase = async <T extends TrackInfo | SetInfo>(url: string, clientID: string, axiosRef: AxiosInstance): Promise<T> => {\n  try {\n    const res = await axiosRef.get(appendURL('https://api-v2.soundcloud.com/resolve', 'url', url, 'client_id', clientID), {\n      withCredentials: true\n    })\n\n    return res.data as T\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\n/** @internal */\nconst getSetInfoBase = async (url: string, clientID: string, axiosRef: AxiosInstance): Promise<SetInfo> => {\n  const setInfo = await getInfoBase<SetInfo>(url, clientID, axiosRef)\n  const originalOrder = setInfo.tracks.map(track => track.id)\n  const playlistID = setInfo.id\n  const playlistSecretToken = setInfo.secret_token\n  const incompleteTracks = setInfo.tracks.filter(track => !track.title)\n\n  if (incompleteTracks.length === 0) {\n    return setInfo\n  }\n\n  const completeTracks = setInfo.tracks.filter(track => track.title)\n  const incompleteIds = incompleteTracks.map(t => t.id)\n\n  if (incompleteIds.length > 50) {\n    const batchSize = 50\n    const batches: number[][] = []\n\n    for (let i = 0; i < incompleteIds.length; i += batchSize) {\n      batches.push(incompleteIds.slice(i, i + batchSize))\n    }\n\n    const promises = batches.map(ids => getTrackInfoByID(clientID, axiosRef, ids, playlistID, playlistSecretToken))\n    const fetchedTracks = await Promise.all(promises)\n    setInfo.tracks = completeTracks.concat(...fetchedTracks)\n  } else {\n    const fetchedTracks = await getTrackInfoByID(clientID, axiosRef, incompleteIds, playlistID, playlistSecretToken)\n    setInfo.tracks = completeTracks.concat(fetchedTracks)\n  }\n\n  setInfo.tracks = sortTracks(setInfo.tracks, originalOrder)\n  return setInfo\n}\n\n/** @internal */\nconst sortTracks = (tracks: TrackInfo[], ids: number[]): TrackInfo[] => {\n  const trackMap = new Map<number, TrackInfo>()\n\n  for (const track of tracks) {\n    trackMap.set(track.id, track)\n  }\n\n  const sorted: TrackInfo[] = []\n  for (const id of ids) {\n    const track = trackMap.get(id)\n    if (track) {\n      sorted.push(track)\n    }\n  }\n\n  return sorted\n}\n\n/** @internal */\nconst getInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<TrackInfo> => {\n  let data: TrackInfo\n\n  if (url.includes('https://soundcloud.com/discover/sets/personalized-tracks::')) {\n    const idString = extractIDFromPersonalizedTrackURL(url)\n    if (!idString) throw new Error('Could not parse track ID from given URL: ' + url)\n\n    const id = parseInt(idString, 10)\n    if (isNaN(id)) {\n      throw new Error('Could not parse track ID from given URL: ' + url)\n    }\n\n    const tracks = await getTrackInfoByID(clientID, axiosInstance, [id])\n    const track = tracks[0]\n    if (!track) throw new Error('Could not find track with ID: ' + id)\n    data = track\n  } else {\n    data = await getInfoBase<TrackInfo>(url, clientID, axiosInstance)\n  }\n\n  if (!data.media) throw new Error('The given URL does not link to a Soundcloud track')\n  return data\n}\n\n/** @internal */\nexport const getSetInfo = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<SetInfo> => {\n  const data = await getSetInfoBase(url, clientID, axiosInstance)\n  if (!data.tracks) throw new Error('The given URL does not link to a Soundcloud set')\n  return data\n}\n\n/** @internal */\nexport const getTrackInfoByID = async (clientID: string, axiosInstance: AxiosInstance, ids: number[], playlistID?: number, playlistSecretToken?: string) => {\n  return await getTrackInfoBase(clientID, axiosInstance, ids, playlistID, playlistSecretToken)\n}\nexport default getInfo\n","import type { Transcoding } from './info'\nimport FORMATS from './formats'\nimport STREAMING_PROTOCOLS from './protocols'\n\nexport interface FilterPredicateObject {\n  protocol?: STREAMING_PROTOCOLS\n  format?: FORMATS\n}\n\n/** @internal */\nconst filterMedia = (\n  media: Transcoding[],\n  predicate: FilterPredicateObject\n): Transcoding[] => {\n  return media.filter(({ format, snipped }) => {\n    // Odrzuć snippety\n    if (snipped) {\n      return false\n    }\n    \n    // Sprawdź protokół jeśli podany\n    if (predicate.protocol !== undefined && format.protocol !== predicate.protocol) {\n      return false\n    }\n    \n    // Sprawdź format jeśli podany\n    if (predicate.format !== undefined && format.mime_type !== predicate.format) {\n      return false\n    }\n    \n    return true\n  })\n}\n\nexport default filterMedia\n","/** @internal @packageDocumentation */\n\nimport type { AxiosInstance } from 'axios'\nimport m3u8stream from 'm3u8stream'\nimport { handleRequestErrs, appendURL } from './util'\nimport getInfo, { type Transcoding } from './info'\n\nexport const getMediaURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<string> => {\n  const res = await axiosInstance.get(appendURL(url, 'client_id', clientID), {\n    headers: {\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.52 Safari/537.36',\n      Accept: '*/*',\n      'Accept-Encoding': 'gzip, deflate, br'\n    },\n    withCredentials: true\n  })\n  if (!res.data.url) throw new Error(`Invalid response from Soundcloud. Check if the URL provided is correct: ${url}`)\n  return res.data.url\n}\n\nexport const getProgressiveStream = async (mediaUrl: string, axiosInstance: AxiosInstance) => {\n  const r = await axiosInstance.get(mediaUrl, {\n    withCredentials: true,\n    responseType: 'stream'\n  })\n\n  return r.data\n}\n\nexport const getHLSStream = (mediaUrl: string) => m3u8stream(mediaUrl)\n\n/** @internal */\ntype fromURLFunctionBase = (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance) => Promise<any | m3u8stream.Stream>\n\nexport const fromURLBase: fromURLFunctionBase = async (url: string, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\n  try {\n    const mediaUrl = await getMediaURLFunction(url, clientID, axiosInstance)\n\n    if (url.includes('/progressive')) {\n      return await getProgressiveStreamFunction(mediaUrl, axiosInstance)\n    }\n\n    return getHLSStreamFunction(mediaUrl)\n  } catch (err) {\n    throw handleRequestErrs(err)\n  }\n}\n\nexport const fromURL = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => await fromURLBase(url, clientID, getMediaURL, getProgressiveStream, getHLSStream, axiosInstance)\n\nexport const fromMediaObjBase = async (media: Transcoding, clientID: string,\n  getMediaURLFunction: (url: string, clientID: string, axiosInstance: AxiosInstance) => Promise<string>,\n  getProgressiveStreamFunction: (mediaUrl: string, axiosInstance: AxiosInstance) => Promise<any>,\n  getHLSStreamFunction: (mediaUrl: string) => m3u8stream.Stream,\n  fromURLFunction: typeof fromURL,\n  axiosInstance: AxiosInstance): Promise<any | m3u8stream.Stream> => {\n  if (!validateMedia(media)) throw new Error('Invalid media object provided')\n  return await fromURLFunction(media.url, clientID, axiosInstance)\n}\n\nexport const fromMediaObj = async (media: Transcoding, clientID: string, axiosInstance: AxiosInstance) => await fromMediaObjBase(media, clientID, getMediaURL, getProgressiveStream, getHLSStream, fromURL, axiosInstance)\n\nexport const fromDownloadLink = async (id: number, clientID: string, axiosInstance: AxiosInstance) => {\n  const { data: { redirectUri } } = await axiosInstance.get(appendURL(`https://api-v2.soundcloud.com/tracks/${id}/download`, 'client_id', clientID))\n  const { data } = await axiosInstance.get(redirectUri, {\n    responseType: 'stream'\n  })\n\n  return data\n}\n\n/**\n * Waliduje czy media transcoding jest prawidłowy\n * @internal\n */\nconst validateMedia = (media: Transcoding): boolean => {\n  if (!media || !media.url || !media.format) return false\n  if (!media.format.protocol) return false\n  // Sprawdź czy protocol jest obsługiwany\n  if (!['hls', 'progressive'].includes(media.format.protocol)) return false\n  return true\n}\n\n/** @internal */\nexport const download = async (url: string, clientID: string, axiosInstance: AxiosInstance, useDownloadLink = true) => {\n  const info = await getInfo(url, clientID, axiosInstance)\n\n  if (info.downloadable && useDownloadLink) {\n    try {\n      return await fromDownloadLink(info.id, clientID, axiosInstance)\n    } catch (err) {\n      console.log('Download link failed, trying transcoding...')\n    }\n  }\n\n  // Ulepszone wybieranie najlepszego transcoding\n  const availableTranscodings = info.media.transcodings.filter((t: Transcoding) =>\n    validateMedia(t) &&\n    t.url &&\n    t.format &&\n    (t.format.protocol === 'hls' || t.format.protocol === 'progressive')\n  )\n\n  if (availableTranscodings.length === 0) {\n    throw new Error('No valid transcoding available for this track')\n  }\n\n  // Preferuj progressive nad HLS (lepiej działa z Discord)\n  const preferredTranscoding = availableTranscodings.find((t: Transcoding) =>\n    t.format.protocol === 'progressive'\n  ) || availableTranscodings[0]\n\n  // Spróbuj wszystkich dostępnych transcodings jeśli pierwszy nie działa\n  for (let i = 0; i < availableTranscodings.length; i++) {\n    const transcoding = availableTranscodings[i]\n    try {\n      return await fromMediaObj(transcoding, clientID, axiosInstance)\n    } catch (err) {\n      console.log(`Transcoding failed: ${transcoding.format.protocol}, trying next...`)\n      if (i === availableTranscodings.length - 1) {\n        throw err // Ostatni transcoding - rzuć błąd\n      }\n    }\n  }\n}\n","import type { AxiosInstance } from 'axios';\n\n/**\n * Regex dopasowujący standardowe i mobilne adresy URL SoundCloud.\n * Obsługuje:\n * - http://soundcloud.com/...\n * - https://soundcloud.com/...\n * - http://m.soundcloud.com/...\n * - https://m.soundcloud.com/...\n */\nconst SOUNDCLOUD_URL_REGEX = /^https?:\\/\\/(m\\.)?soundcloud\\.com\\/.+/;\n\n/**\n * Regex dopasowujący adresy URL skracacza linków Firebase używanego przez SoundCloud.\n */\n/**\n * Regex dopasowujący adresy URL skracaczy linków używanych przez SoundCloud (Firebase i on.soundcloud).\n * Obsługuje np:\n * - https://soundcloud.app.goo.gl/...\n * - https://on.soundcloud.com/...\n */\nconst FIREBASE_URL_REGEX = /^https?:\\/\\/(?:soundcloud\\.app\\.goo\\.gl|on\\.soundcloud\\.com)\\/.+/;\n\n/**\n * Ogólny regex do wyszukiwania (scrapowania) dowolnego adresu URL w tekście.\n * Używany do znalezienia docelowego linku SoundCloud w odpowiedzi z linku Firebase.\n */\nconst GENERIC_URL_SCRAPE_REGEX = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,500}\\.[a-zA-Z0-9()]{1,500}\\b([-a-zA-Z0-9()@:%_+.~#?&/\\\\=;]*)/g;\n\n/**\n * Stały prefix do sprawdzania spersonalizowanych URL\n */\nconst PERSONALIZED_TRACK_PREFIX = 'https://soundcloud.com/discover/sets/personalized-tracks::';\n\n// --- Funkcje pomocnicze ---\n\n/**\n * Sprawdza, czy podany ciąg znaków jest prawidłowym adresem URL SoundCloud (standardowym, mobilnym lub Firebase).\n * @param url - Adres URL do przetestowania.\n * @param testFirebase - Czy uwzględnić sprawdzanie linków Firebase (domyślnie true).\n * @returns `true`, jeśli adres URL jest prawidłowy, w przeciwnym razie `false`.\n */\nexport const isURL = (url: string, testFirebase: boolean = true, stripMobilePrefix?: boolean): boolean => {\n  if (typeof url !== 'string') return false;\n  // Sprawdza, czy pasuje do standardowego/mobilnego URL-a LUB (jeśli włączone) do URL-a Firebase.\n  return SOUNDCLOUD_URL_REGEX.test(url) || (testFirebase && FIREBASE_URL_REGEX.test(url));\n};\n\n/**\n * Sprawdza, czy URL prowadzi do playlisty (setu) na SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli URL jest playlistą, w przeciwnym razie `false`.\n */\nexport const isPlaylistURL = (url: string): boolean => {\n  // `isURL` sprawdza teraz również format linku Firebase, więc testFirebase ustawiamy na false,\n  // aby upewnić się, że analizujemy już rozwiązany URL SoundCloud.\n  if (!isURL(url, false)) {\n    return false;\n  }\n\n  // Szybkie sprawdzenie string przed parsowaniem URL\n  if (!url.includes('/sets/')) {\n    return false;\n  }\n\n  try {\n    const parsedUrl = new URL(url);\n    // Dodatkowe, bardziej rygorystyczne sprawdzenie ścieżki\n    return parsedUrl.pathname.includes('/sets/');\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Sprawdza, czy URL jest linkiem do spersonalizowanej playlisty \"Odkrywaj\" na SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli URL jest spersonalizowaną playlistą, w przeciwnym razie `false`.\n */\nexport const isPersonalizedTrackURL = (url: string): boolean => {\n  if (typeof url !== 'string') return false;\n  return url.startsWith(PERSONALIZED_TRACK_PREFIX);\n};\n\n/**\n * Usuwa prefiks mobilny 'm.' z adresu URL SoundCloud.\n * @param url - Adres URL do przetworzenia.\n * @returns Adres URL bez prefiksu mobilnego lub oryginalny URL, jeśli nie był to link mobilny.\n */\nexport const stripMobilePrefix = (url: string): string => {\n  try {\n    const urlObject = new URL(url);\n    if (urlObject.hostname === 'm.soundcloud.com') {\n      urlObject.hostname = 'soundcloud.com';\n      return urlObject.toString();\n    }\n    return url;\n  } catch {\n    // Zwraca oryginalny URL w przypadku błędu parsowania (np. nieprawidłowy URL)\n    return url;\n  }\n};\n\n/**\n * Sprawdza, czy URL jest skróconym linkiem Firebase od SoundCloud.\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli to link Firebase, w przeciwnym razie `false`.\n */\n/**\n * Sprawdza, czy URL jest skróconym linkiem SoundCloud (np. Firebase shortener lub on.soundcloud.com).\n * @param url - Adres URL do sprawdzenia.\n * @returns `true`, jeśli to skrócony link SoundCloud, w przeciwnym razie `false`.\n */\nexport const isFirebaseURL = (url: string): boolean => {\n  if (typeof url !== 'string') return false;\n  return FIREBASE_URL_REGEX.test(url);\n};\n\n/**\n * Konwertuje skrócony link Firebase na pełny adres URL SoundCloud.\n * Pobiera zawartość strony z linku Firebase i wyszukuje w niej docelowy URL.\n * @param url - Skrócony URL Firebase (np. https://soundcloud.app.goo.gl/xyz).\n * @param axiosInstance - Instancja Axios do wykonania zapytania HTTP.\n * @returns Obietnica (Promise) rozwiązująca się do pełnego adresu URL SoundCloud lub `undefined`, jeśli nie można go znaleźć.\n * @throws Błąd, jeśli nie uda się znaleźć docelowego URL.\n */\nexport const convertFirebaseURL = async (url: string, axiosInstance: AxiosInstance): Promise<string | undefined> => {\n  const urlObject = new URL(url);\n  // Dodanie parametru 'd=1' może czasem pomóc w ominięciu przekierowań i uzyskaniu strony z metadanymi.\n  urlObject.searchParams.set('d', '1');\n\n  // Pobieramy zawartość HTML ze skróconego linku, ponieważ często zawiera on docelowy URL w tagach meta lub skryptach.\n  const { data: htmlContent } = await axiosInstance.get<string>(urlObject.toString());\n\n  // Reset lastIndex dla bezpieczeństwa (regex z flagą 'g' zachowuje stan)\n  GENERIC_URL_SCRAPE_REGEX.lastIndex = 0;\n  const allUrlsInHtml = htmlContent.match(GENERIC_URL_SCRAPE_REGEX);\n\n  if (!allUrlsInHtml || allUrlsInHtml.length === 0) {\n    throw new Error(`Could not find any URL in the response from the Firebase URL: ${url}`);\n  }\n\n  // Znajdź pierwszy URL, który jest prawidłowym linkiem do SoundCloud.\n  const soundcloudUrl = allUrlsInHtml.find(match => SOUNDCLOUD_URL_REGEX.test(match));\n\n  if (!soundcloudUrl) {\n    return undefined;\n  }\n\n  // Czasami URL w odpowiedzi jest zakodowany (np. \\u003d zamiast =).\n  // Ta operacja dekoduje znaki Unicode do ich standardowej postaci.\n  // Przykład: '.../tracks\\u003d123' -> '.../tracks=123'\n  return soundcloudUrl.replace(/\\\\u([\\d\\w]{4})/gi, (_match, grp) =>\n    String.fromCharCode(parseInt(grp, 16)),\n  );\n};\n\n// Eksport domyślny pozostaje bez zmian dla zgodności wstecznej.\nexport default isURL;\n","/* eslint-disable camelcase */\nimport type { AxiosInstance } from 'axios'\nimport type { TrackInfo, User, SetInfo } from './info'\nimport { appendURL, type PaginatedQuery } from './util'\n\nconst baseURL = 'https://api-v2.soundcloud.com/search'\n\nexport interface RelatedResponse<T> extends PaginatedQuery<T> {\n  variant: string\n}\n\nexport interface SearchOptions {\n  limit?: number,\n  offset?: number,\n  resourceType?: SoundcloudResource | 'all',\n  query?: string,\n  nextHref?: string,\n  q?: string\n}\n\nexport type SearchResponseAll = PaginatedQuery<User | SetInfo | TrackInfo>\nexport type SoundcloudResource = 'tracks' | 'users' | 'albums' | 'playlists'\n\nconst validResourceTypes = ['tracks', 'users', 'albums', 'playlists', 'all'] as const\n\n// Funkcja do normalizacji stringów (usuwa znaki specjalne, akcenty, małe litery)\nconst normalizeString = (str: string): string => {\n  return str\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // usuń akcenty\n    .replace(/[^\\w\\s]/g, ' ') // zamień znaki specjalne na spacje\n    .replace(/\\s+/g, ' ') // zamień wielokrotne spacje na jedną\n    .trim()\n}\n\n// Funkcja do obliczania podobieństwa między tytułami\nconst calculateSimilarity = (query: string, title: string): number => {\n  const normalizedQuery = normalizeString(query)\n  const normalizedTitle = normalizeString(title)\n\n  // Jeśli tytuły są identyczne po normalizacji - maksymalny wynik\n  if (normalizedQuery === normalizedTitle) {\n    return 1000\n  }\n\n  // Sprawdź czy query jest dokładnie zawarte w tytule\n  if (normalizedTitle.includes(normalizedQuery)) {\n    return 800\n  }\n\n  // Sprawdź czy wszystkie słowa z query są w tytule\n  const queryWords = normalizedQuery.split(' ').filter(word => word.length > 0)\n  const titleWords = normalizedTitle.split(' ').filter(word => word.length > 0)\n\n  let matchingWords = 0\n  let exactMatches = 0\n\n  queryWords.forEach(queryWord => {\n    // Sprawdź dokładne dopasowanie\n    if (titleWords.some(titleWord => titleWord === queryWord)) {\n      exactMatches++\n      matchingWords++\n    }\n    // Sprawdź częściowe dopasowanie (słowo zawiera się w innym)\n    else if (titleWords.some(titleWord =>\n      titleWord.includes(queryWord) || queryWord.includes(titleWord)\n    )) {\n      matchingWords += 0.5\n    }\n  })\n\n  // Kara za dodatkowe słowa w tytule (preferuj krótsze, dokładniejsze tytuły)\n  const extraWords = Math.max(0, titleWords.length - queryWords.length)\n  const lengthPenalty = extraWords * 10\n\n  // Bonus za dokładne dopasowania\n  const exactMatchBonus = exactMatches * 100\n\n  // Bazowy wynik na podstawie % dopasowanych słów\n  const baseScore = (matchingWords / queryWords.length) * 500\n\n  return Math.max(0, baseScore + exactMatchBonus - lengthPenalty)\n}\n\n// Funkcja do sprawdzania czy to remix/cover/live version\nconst isOriginalVersion = (title: string, query: string): boolean => {\n  const normalizedTitle = normalizeString(title)\n\n  const modifierKeywords = [\n    'remix', 'cover', 'live', 'acoustic', 'instrumental', 'karaoke',\n    'extended', 'radio edit', 'club mix', 'dub', 'version', 'edit',\n    'remaster', 'rework', 'bootleg', 'mashup', 'flip'\n  ]\n\n  // Sprawdź czy tytuł zawiera słowa wskazujące na modyfikację\n  const hasModifiers = modifierKeywords.some(keyword =>\n    normalizedTitle.includes(keyword)\n  )\n\n  // Sprawdź czy query zawiera te słowa (jeśli tak, to użytkownik ich szuka)\n  const queryWantsModified = modifierKeywords.some(keyword =>\n    normalizeString(query).includes(keyword)\n  )\n\n  // Jeśli query nie zawiera modyfikatorów, ale tytuł tak - to prawdopodobnie nie oryginał\n  return !hasModifiers || queryWantsModified\n}\n\n/**\n * Waliduje czy track jest dostępny do streamowania\n * @internal\n */\nconst isTrackValid = (track: any): boolean => {\n  // Podstawowe sprawdzenia\n  if (!track || typeof track !== 'object') return false\n  if (!track.permalink_url || !track.title) return false\n\n  // Odrzucaj sample o długości w pobliżu 30s (29.5–30.5 sekundy)\n  if (\n    typeof track.duration === 'number' &&\n    track.duration >= 29500 &&\n    track.duration <= 30500\n  ) return false\n\n  // Sprawdź dostępność regionalną\n  if ('region_restricted' in track && track.region_restricted === true) return false\n\n  // Sprawdź czy można streamować\n  if (track.streamable !== true) return false\n\n  // Sprawdź stan utworu\n  if (track.state && track.state !== 'finished') return false\n\n  // Sprawdź policy (blokady)\n  if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\n\n  // Sprawdź czy ma media/transcodings\n  if (!track.media || !track.media.transcodings || track.media.transcodings.length === 0) return false\n\n  // Sprawdź czy ma dostępne formaty streamowania\n  const hasValidFormat = track.media.transcodings.some((transcoding: any) =>\n    transcoding &&\n    transcoding.url &&\n    (transcoding.format?.protocol === 'hls' || transcoding.format?.protocol === 'progressive')\n  )\n\n  if (!hasValidFormat) return false\n\n  // Odrzucaj deleted/private tracks\n  if (track.sharing === 'private' && !track.streamable) return false\n\n  return true\n}\n\n/** @internal */\nexport const search = async (\n  options: SearchOptions,\n  axiosInstance: AxiosInstance,\n  clientID: string\n): Promise<SearchResponseAll> => {\n  let url = ''\n  if (!options.limit) options.limit = 20 // Zwiększ limit żeby mieć więcej opcji\n  if (!options.offset) options.offset = 0\n  if (!options.resourceType) options.resourceType = 'tracks'\n\n  // Obsługa zarówno options.query jak i options.q\n  const queryString = options.query || options.q\n\n  if (options.nextHref) {\n    url = appendURL(options.nextHref, 'client_id', clientID)\n  } else if (queryString) {\n    if (!validResourceTypes.includes(options.resourceType as any)) {\n      throw new Error(\n        `${options.resourceType} is not one of ${validResourceTypes\n          .map(str => `'${str}'`)\n          .join(', ')}`\n      )\n    }\n    url = appendURL(\n      `${baseURL}${options.resourceType === 'all' ? '' : `/${options.resourceType}`}`,\n      'client_id',\n      clientID,\n      'q',\n      queryString,\n      'limit',\n      String(options.limit),\n      'offset',\n      String(options.offset)\n    )\n  } else {\n    throw new Error('One of options.query, options.q, or options.nextHref is required')\n  }\n\n  const { data } = await axiosInstance.get(url)\n\n  if (options.resourceType === 'tracks' && Array.isArray(data.collection)) {\n    // Filtruj nieprawidłowe tracki\n    data.collection = data.collection.filter(isTrackValid)\n\n    // Sortuj wyniki na podstawie dokładności dopasowania do query\n    if (queryString) {\n      data.collection.sort((a: any, b: any) => {\n        const similarityA = calculateSimilarity(queryString, a.title)\n        const similarityB = calculateSimilarity(queryString, b.title)\n\n        // Bonus za oryginalną wersję\n        const originalBonusA = isOriginalVersion(a.title, queryString) ? 50 : 0\n        const originalBonusB = isOriginalVersion(b.title, queryString) ? 50 : 0\n\n        // Bonus za popularność (ale mniejszy niż dokładność)\n        const popularityA = (a.likes_count || 0) / 1000\n        const popularityB = (b.likes_count || 0) / 1000\n\n        const scoreA = similarityA + originalBonusA + popularityA\n        const scoreB = similarityB + originalBonusB + popularityB\n\n        return scoreB - scoreA\n      })\n    }\n\n    // Ogranicz do oryginalnego limitu (ale po filtrowaniu i sortowaniu)\n    data.collection = data.collection.slice(0, Math.min(options.limit, 10))\n  }\n\n  return data as SearchResponseAll\n}\n\n/** @internal */\nexport const related = async <T extends TrackInfo>(\n  id: number,\n  limit = 10,\n  offset = 0,\n  axiosInstance: AxiosInstance,\n  clientID: string\n): Promise<RelatedResponse<T>> => {\n  const { data } = await axiosInstance.get(\n    appendURL(\n      `https://api-v2.soundcloud.com/tracks/${id}/related`,\n      'client_id',\n      clientID,\n      'offset',\n      String(offset),\n      'limit',\n      String(limit)\n    )\n  )\n\n  // Zastosuj podobne filtrowanie dla related tracks\n  if (Array.isArray(data.collection)) {\n    data.collection = data.collection.filter((track: any) => {\n      if (!track || typeof track !== 'object') return false\n      if (!track.permalink_url || !track.title) return false\n\n      // Odrzucaj sample ~30s\n      if (\n        typeof track.duration === 'number' &&\n        track.duration >= 29500 &&\n        track.duration <= 30500\n      ) return false\n\n      // Odrzucaj zbyt krótkie\n      if (\n        typeof track.duration === 'number' &&\n        track.duration < 10000\n      ) return false\n\n      if (track.streamable !== true) return false\n      if (track.state && track.state !== 'finished') return false\n      if (track.policy === 'BLOCK' || track.policy === 'SNIP') return false\n\n      return true\n    })\n  }\n\n  return data as RelatedResponse<T>\n}\n","import type { AxiosInstance } from 'axios'\nimport { download } from './download'\nimport { getSetInfo, type TrackInfo } from './info'\n\nexport const downloadPlaylist = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<[ReadableStream<any>[], string[]]> => {\n  const info = await getSetInfo(url, clientID, axiosInstance)\n\n  const trackNames: string[] = []\n  const result = await Promise.all(info.tracks.map((track: TrackInfo) => {\n    const p = download(track.permalink_url, clientID, axiosInstance)\n    trackNames.push(track.title)\n    return p\n  }))\n\n  return [result, trackNames]\n}\n","import type { AxiosInstance } from 'axios'\nimport type { TrackInfo } from './info'\nimport { appendURL, kindMismatchError, type PaginatedQuery } from './util'\n\nconst baseURL = 'https://api-v2.soundcloud.com/users/'\n\nexport interface Like {\n  // eslint-disable-next-line camelcase\n  created_at: string,\n  kind: string,\n  track: TrackInfo\n}\n\nexport interface GetLikesOptions {\n  profileUrl?: string\n  id?: number\n  limit?: number // -1 indicates no limit\n  offset?: number\n  nextHref?: string\n}\n\n/** @internal */\nexport const getLikes = async (options: GetLikesOptions, clientID: string, axiosInstance: AxiosInstance): Promise<PaginatedQuery<Like>> => {\n  let u = ''\n  if (!options.nextHref) {\n    if (options.limit === undefined) options.limit = -1\n    if (options.offset === undefined) options.offset = 0\n    u = appendURL(\n      `https://api-v2.soundcloud.com/users/${options.id}/likes`,\n      'client_id', clientID,\n      'limit', String(options.limit === -1 ? 200 : options.limit),\n      'offset', String(options.offset))\n  } else {\n    u = appendURL(options.nextHref, 'client_id', clientID)\n  }\n\n  let response!: PaginatedQuery<Like>\n  let nextHref: string | undefined = 'start'\n\n  // If options.limit > 0, query each page of likes until we have collected\n  // `options.limit` liked tracks.\n  // If options.limit === -1, query every page of likes\n  while (nextHref && (options.limit > 0 || options.limit === -1)) {\n    const { data } = await axiosInstance.get(u)\n    const query = data as PaginatedQuery<Like>\n\n    if (!query.collection) throw new Error('Invalid JSON response received')\n    if (query.collection.length === 0) return data\n    if (query.collection[0].kind !== 'like') throw kindMismatchError('like', query.collection[0].kind)\n\n    // Only add tracks (for now)\n    query.collection = query.collection.reduce<Like[]>((prev, curr) =>\n      curr.track ? prev.concat(curr) : prev,\n      [])\n\n    if (!response) {\n      response = query\n    } else {\n      response.collection.push(...query.collection)\n    }\n\n    if (options.limit !== -1) {\n      options.limit -= query.collection.length\n      // We have collected enough likes\n      if (options.limit <= 0) break\n    }\n\n    nextHref = query.next_href\n    if (nextHref) {\n      if (options.limit !== -1) {\n        const url = new URL(nextHref)\n        url.searchParams.set('limit', String(options.limit))\n        nextHref = url.toString()\n      }\n      u = appendURL(nextHref, 'client_id', clientID)\n    }\n  }\n\n  return response\n}\n","import type { AxiosInstance } from 'axios'\nimport type { User } from './info'\nimport { appendURL, resolveURL } from './util'\n\n/** @internal */\nexport const getUser = async (url: string, clientID: string, axiosInstance: AxiosInstance): Promise<User> => {\n  const u = appendURL(resolveURL, 'url', url, 'client_id', clientID)\n  const { data } = await axiosInstance.get(u)\n\n  if (!(data as User).avatar_url) throw new Error('JSON response is not a user. Is profile URL correct? : ' + url)\n\n  return data as User\n}\n","import sckey from 'soundcloud-key-fetch'\n\nimport getInfo, { getSetInfo, getTrackInfoByID, type Transcoding, type TrackInfo, type User } from './info'\nimport filterMedia, { type FilterPredicateObject } from './filter-media'\nimport { download, fromMediaObj } from './download'\n\nimport isValidURL, { convertFirebaseURL, isFirebaseURL, isPersonalizedTrackURL, isPlaylistURL, stripMobilePrefix } from './url'\n\nimport STREAMING_PROTOCOLS, { _PROTOCOLS } from './protocols'\nimport FORMATS, { _FORMATS } from './formats'\nimport { search, related, type SoundcloudResource, type SearchOptions } from './search'\nimport { downloadPlaylist } from './download-playlist'\nimport axios, { type AxiosInstance, type AxiosError } from 'axios'\n\nimport * as path from 'path'\nimport * as fs from 'fs'\nimport { type PaginatedQuery } from './util'\nimport { getLikes, type GetLikesOptions, type Like } from './likes'\nimport { getUser } from './user'\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Default maximum number of retry attempts */\nconst DEFAULT_MAX_RETRIES = 3\n/** Default delay between retries in milliseconds */\nconst DEFAULT_RETRY_DELAY = 1000\n/** Default request timeout in milliseconds */\nconst DEFAULT_TIMEOUT = 30000\n/** Client ID cache expiry time (24 hours) */\nconst CLIENT_ID_EXPIRY_MS = 24 * 60 * 60 * 1000\n/** Minimum duration for sample track detection (ms) */\nconst SAMPLE_DURATION_MIN = 29500\n/** Maximum duration for sample track detection (ms) */\nconst SAMPLE_DURATION_MAX = 30500\n/** One hour in milliseconds */\nconst ONE_HOUR_MS = 60 * 60 * 1000\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/** Error types for better error handling */\nexport enum SCDLErrorType {\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  INVALID_URL = 'INVALID_URL',\n  CLIENT_ID_ERROR = 'CLIENT_ID_ERROR',\n  TRACK_NOT_FOUND = 'TRACK_NOT_FOUND',\n  REGION_RESTRICTED = 'REGION_RESTRICTED',\n  NOT_STREAMABLE = 'NOT_STREAMABLE',\n  SAMPLE_TRACK = 'SAMPLE_TRACK',\n  FORMAT_NOT_FOUND = 'FORMAT_NOT_FOUND',\n  FILE_SYSTEM_ERROR = 'FILE_SYSTEM_ERROR',\n  PARSING_ERROR = 'PARSING_ERROR',\n  RATE_LIMITED = 'RATE_LIMITED'\n}\n\n/**\n * Extracts error message from unknown error type\n * @internal\n */\nconst getErrorMessage = (error: unknown): string => {\n  if (error instanceof Error) return error.message\n  if (typeof error === 'string') return error\n  return String(error)\n}\n\n/** Custom error class with typed error information */\nexport class SCDLError extends Error {\n  public readonly type: SCDLErrorType\n  public readonly originalError: Error | undefined\n  public readonly url: string | undefined\n  public readonly retryAfter: number | undefined\n\n  constructor(\n    message: string,\n    type: SCDLErrorType,\n    originalError?: Error,\n    url?: string,\n    retryAfter?: number\n  ) {\n    super(message)\n    this.name = 'SCDLError'\n    this.type = type\n    this.originalError = originalError\n    this.url = url\n    this.retryAfter = retryAfter\n\n    // Maintain proper stack trace for V8 engines\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, SCDLError)\n    }\n  }\n}\n\n/** @internal */\nconst downloadFormat = async (url: string, clientID: string, format: FORMATS, axiosInstance: AxiosInstance) => {\n  try {\n    const info = await getInfo(url, clientID, axiosInstance)\n    const filtered = filterMedia(info.media.transcodings, { format: format })\n    if (filtered.length === 0) {\n      throw new SCDLError(\n        `Nie można znaleźć mediów w określonym formacie: (${format})`,\n        SCDLErrorType.FORMAT_NOT_FOUND,\n        undefined,\n        url\n      )\n    }\n    return await fromMediaObj(filtered[0], clientID, axiosInstance)\n  } catch (error) {\n    if (error instanceof SCDLError) throw error\n    throw new SCDLError(\n      `Błąd podczas pobierania formatu: ${getErrorMessage(error)}`,\n      SCDLErrorType.NETWORK_ERROR,\n      error instanceof Error ? error : undefined,\n      url\n    )\n  }\n}\n\ninterface ClientIDData {\n  clientID: string,\n  date: Date\n}\n\nexport interface SCDLOptions {\n  // Set a custom client ID to use\n  clientID?: string,\n  // Set to true to save client ID to file\n  saveClientID?: boolean,\n  // File path to save client ID, defaults to '../client_id.json\"\n  filePath?: string,\n  // Custom axios instance to use\n  axiosInstance?: AxiosInstance,\n  // Whether or not to automatically convert mobile links to regular links, defaults to true\n  stripMobilePrefix?: boolean,\n  // Whether or not to automatically convert SoundCloud Firebase links copied from the mobile app\n  // (e.g. https://soundcloud.app.goo.gl/xxxxxxxxx), defaults to true.\n  convertFirebaseLinks?: boolean,\n  // Nowe opcje\n  // Maximum number of retries for failed requests\n  maxRetries?: number,\n  // Base delay between retries in milliseconds\n  retryDelay?: number,\n  // Request timeout in milliseconds\n  timeout?: number,\n  // Whether to validate URLs before processing\n  validateUrls?: boolean\n}\n\n// Nowe interfejsy pomocnicze\ninterface RetryConfig {\n  maxRetries: number\n  retryDelay: number\n  currentAttempt: number\n}\n\nexport class SCDL {\n  STREAMING_PROTOCOLS: { [key: string]: STREAMING_PROTOCOLS }\n  FORMATS: { [key: string]: FORMATS }\n\n  private _clientID?: string\n  private _filePath?: string\n  private _maxRetries: number\n  private _retryDelay: number\n  private _timeout: number\n  private _validateUrls: boolean\n\n  axios: AxiosInstance\n  saveClientID = process.env.SAVE_CLIENT_ID ? process.env.SAVE_CLIENT_ID.toLowerCase() === 'true' : false\n\n  stripMobilePrefix: boolean\n  convertFirebaseLinks: boolean\n\n  constructor(options?: SCDLOptions) {\n    if (!options) options = {}\n\n    // Zachowaj starą logikę\n    if (options.saveClientID) {\n      this.saveClientID = options.saveClientID\n      if (options.filePath) this._filePath = options.filePath\n    } else {\n      if (options.clientID) {\n        this._clientID = options.clientID\n      }\n    }\n\n    // Nowe opcje z wartościami domyślnymi\n    this._maxRetries = options.maxRetries ?? 3\n    this._retryDelay = options.retryDelay ?? 1000\n    this._timeout = options.timeout ?? 30000\n    this._validateUrls = options.validateUrls ?? true\n\n    if (options.axiosInstance) {\n      this.setAxiosInstance(options.axiosInstance)\n    } else {\n      this.setAxiosInstance(axios)\n    }\n\n    // Konfiguruj axios z timeout i interceptorami\n    this._setupAxiosInterceptors()\n\n    if (options.stripMobilePrefix === undefined) options.stripMobilePrefix = true\n    if (options.convertFirebaseLinks === undefined) options.convertFirebaseLinks = true\n\n    this.stripMobilePrefix = options.stripMobilePrefix\n    this.convertFirebaseLinks = options.convertFirebaseLinks\n\n    // Ustaw protokoły i formaty\n    this.STREAMING_PROTOCOLS = _PROTOCOLS\n    this.FORMATS = _FORMATS\n  }\n  /**\n   * Parsuje nagłówek retry-after który może być w sekundach lub jako data HTTP\n   * @internal\n   */\n  private _parseRetryAfter(retryAfterHeader: string | number | undefined): number {\n    if (!retryAfterHeader) {\n      return this._retryDelay\n    }\n\n    const retryAfterStr = String(retryAfterHeader).trim()\n\n    // Sprawdź czy to liczba (sekundy)\n    if (/^\\d+$/.test(retryAfterStr)) {\n      const seconds = parseInt(retryAfterStr, 10)\n      return Math.max(seconds * 1000, this._retryDelay) // Konwertuj na milisekundy\n    }\n\n    // Sprawdź czy to data HTTP (RFC 7231)\n    try {\n      const retryDate = new Date(retryAfterStr)\n\n      // Sprawdź czy data jest poprawna\n      if (isNaN(retryDate.getTime())) {\n        console.warn(`Nieprawidłowy format retry-after: ${retryAfterStr}`)\n        return this._retryDelay\n      }\n\n      const now = new Date()\n      const delayMs = retryDate.getTime() - now.getTime()\n\n      // Jeśli data jest w przeszłości lub za daleko w przyszłości (>1h), użyj domyślnego delay\n      if (delayMs <= 0) {\n        console.warn(`Retry-after data w przeszłości: ${retryAfterStr}`)\n        return this._retryDelay\n      }\n\n      const oneHourMs = 60 * 60 * 1000\n      if (delayMs > oneHourMs) {\n        console.warn(`Retry-after data zbyt daleko w przyszłości: ${retryAfterStr}, używam 1 godziny`)\n        return oneHourMs\n      }\n\n      return delayMs\n    } catch (error) {\n      console.warn(`Błąd parsowania retry-after jako data: ${retryAfterStr}`, error)\n      return this._retryDelay\n    }\n  }\n  /**\n   * Konfiguruje interceptory dla axios\n   * @internal\n   */\n  private _setupAxiosInterceptors() {\n    this.axios.defaults.timeout = this._timeout\n\n    // Response interceptor dla obsługi błędów\n    this.axios.interceptors.response.use(\n      (response) => response,\n      (error: AxiosError) => {\n        if (error.response) {\n          const status = error.response.status\n          if (status === 429) {\n            const retryAfter = this._parseRetryAfter(error.response.headers['retry-after'])\n            throw new SCDLError(\n              'Przekroczono limit zapytań. Spróbuj ponownie później.',\n              SCDLErrorType.RATE_LIMITED,\n              error,\n              error.config?.url,\n              retryAfter\n            )\n          } else if (status === 404) {\n            throw new SCDLError(\n              'Nie znaleziono zasobu.',\n              SCDLErrorType.TRACK_NOT_FOUND,\n              error,\n              error.config?.url\n            )\n          } else if (status >= 500 && status < 600) {\n            throw new SCDLError(\n              `Błąd serwera (${status}): ${error.response.statusText}`,\n              SCDLErrorType.NETWORK_ERROR,\n              error,\n              error.config?.url\n            )\n          } else if (status === 403) {\n            throw new SCDLError(\n              'Brak dostępu do zasobu. Możliwe że zasób jest prywatny lub Client ID jest nieprawidłowy.',\n              SCDLErrorType.CLIENT_ID_ERROR,\n              error,\n              error.config?.url\n            )\n          } else if (status === 401) {\n            throw new SCDLError(\n              'Nieautoryzowany dostęp. Client ID może być nieprawidłowy.',\n              SCDLErrorType.CLIENT_ID_ERROR,\n              error,\n              error.config?.url\n            )\n          }\n        }\n\n        if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {\n          throw new SCDLError(\n            'Przekroczono limit czasu żądania.',\n            SCDLErrorType.NETWORK_ERROR,\n            error,\n            error.config?.url\n          )\n        }\n\n        if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\n          throw new SCDLError(\n            'Nie można połączyć się z serwerem SoundCloud.',\n            SCDLErrorType.NETWORK_ERROR,\n            error,\n            error.config?.url\n          )\n        }\n\n        throw new SCDLError(\n          `Błąd sieci: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error,\n          error.config?.url\n        )\n      }\n    )\n  }\n\n  /**\n   * Wykonuje operację z retry logic\n   * @internal\n   */\n  private async _withRetry<T>(\n    operation: () => Promise<T>,\n    config: Partial<RetryConfig> = {}\n  ): Promise<T> {\n    const retryConfig: RetryConfig = {\n      maxRetries: this._maxRetries,\n      retryDelay: this._retryDelay,\n      currentAttempt: 0,\n      ...config\n    }\n\n    while (retryConfig.currentAttempt <= retryConfig.maxRetries) {\n      try {\n        return await operation()\n      } catch (error) {\n        retryConfig.currentAttempt++\n\n        if (error instanceof SCDLError) {\n          // Niektóre błędy nie powinny być retryowane\n          if ([\n            SCDLErrorType.INVALID_URL,\n            SCDLErrorType.REGION_RESTRICTED,\n            SCDLErrorType.NOT_STREAMABLE,\n            SCDLErrorType.SAMPLE_TRACK,\n            SCDLErrorType.FORMAT_NOT_FOUND\n          ].includes(error.type)) {\n            throw error\n          }\n\n          // Użyj retry-after dla rate limiting\n          if (error.type === SCDLErrorType.RATE_LIMITED && error.retryAfter) {\n            if (retryConfig.currentAttempt <= retryConfig.maxRetries) {\n              await this._delay(error.retryAfter)\n              continue\n            }\n          }\n        }\n\n        if (retryConfig.currentAttempt > retryConfig.maxRetries) {\n          throw error\n        }\n\n        // Exponential backoff\n        const delay = retryConfig.retryDelay * Math.pow(2, retryConfig.currentAttempt - 1)\n        await this._delay(delay)\n      }\n    }\n\n    throw new Error('Nieoczekiwany błąd w logice retry')\n  }\n\n  /**\n   * Pomocnicza funkcja delay\n   * @internal\n   */\n  private _delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Waliduje URL z lepszą obsługą błędów\n   * @internal\n   */\n  private _validateUrl(url: string, operation: string): void {\n    if (!this._validateUrls) return\n\n    try {\n      if (!url || typeof url !== 'string') {\n        throw new SCDLError(\n          'URL musi być niepustym stringiem.',\n          SCDLErrorType.INVALID_URL,\n          undefined,\n          url\n        )\n      }\n\n      if (!this.isValidUrl(url)) {\n        throw new SCDLError(\n          `Nieprawidłowy URL SoundCloud: ${url}`,\n          SCDLErrorType.INVALID_URL,\n          undefined,\n          url\n        )\n      }\n    } catch (error) {\n      if (error instanceof SCDLError) throw error\n      throw new SCDLError(\n        `Błąd podczas walidacji URL dla operacji ${operation}: ${getErrorMessage(error)}`,\n        SCDLErrorType.INVALID_URL,\n        error as Error,\n        url\n      )\n    }\n  }\n\n  /**\n   * Returns a media Transcoding that matches the given predicate object\n   * @param media - The Transcodings to filter\n   * @param predicateObj - The desired Transcoding object to match\n   * @returns An array of Transcodings that match the predicate object\n   */\n  filterMedia(media: Transcoding[], predicateObj: FilterPredicateObject) {\n    try {\n      return filterMedia(media, predicateObj)\n    } catch (error) {\n      throw new SCDLError(\n        `Błąd podczas filtrowania mediów: ${getErrorMessage(error)}`,\n        SCDLErrorType.PARSING_ERROR,\n        error as Error\n      )\n    }\n  }\n\n  /**\n   * Get the audio of a given track. It returns the first format found.\n   *\n   * @param url - The URL of the Soundcloud track\n   * @param useDirectLink - Whether or not to use the download link if the artist has set the track to be downloadable. This has erratic behaviour on some environments.\n   * @returns A ReadableStream containing the audio data\n  */\n  async download(url: string, useDirectLink = true) {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'download')\n\n      try {\n        // POBIERZ INFO O TRACKU\n        const info = await this.getInfo(url)\n\n        // ODRZUĆ SAMPLE ~30s (+/- 0.6s) I OGRANICZENIA REGIONALNE\n        if (\n          typeof info.duration === 'number' &&\n          info.duration >= 29500 &&\n          info.duration <= 30500\n        ) {\n          throw new SCDLError(\n            'Ten utwór to najprawdopodobniej 30-sekundowy sample/prewka SoundCloud!',\n            SCDLErrorType.SAMPLE_TRACK,\n            undefined,\n            url\n          )\n        }\n\n        if ('region_restricted' in info && info.region_restricted === true) {\n          throw new SCDLError(\n            'Ten utwór jest niedostępny w Twoim regionie!',\n            SCDLErrorType.REGION_RESTRICTED,\n            undefined,\n            url\n          )\n        }\n\n        if (info.streamable !== true) {\n          throw new SCDLError(\n            'Nie można streamować tego utworu!',\n            SCDLErrorType.NOT_STREAMABLE,\n            undefined,\n            url\n          )\n        }\n\n        // Jeśli przeszedł checki, pobieraj!\n        const preparedUrl = await this.prepareURL(url)\n        return download(preparedUrl, await this.getClientID(), this.axios, useDirectLink)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania utworu: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   *  Get the audio of a given track with the specified format\n   * @param url - The URL of the Soundcloud track\n   * @param format - The desired format\n  */\n  async downloadFormat(url: string, format: FORMATS) {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'downloadFormat')\n\n      try {\n        const preparedUrl = await this.prepareURL(url)\n        return downloadFormat(preparedUrl, await this.getClientID(), format, this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania formatu ${format}: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns info about a given track.\n   * @param url - URL of the Soundcloud track\n   * @returns Info about the track\n  */\n  async getInfo(url: string) {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'getInfo')\n\n      try {\n        const preparedUrl = await this.prepareURL(url)\n        return getInfo(preparedUrl, await this.getClientID(), this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania informacji o utworze: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns info about the given track(s) specified by ID.\n   * @param ids - The ID(s) of the tracks\n   * @returns Info about the track\n   */\n  async getTrackInfoByID(ids: number[], playlistID?: number, playlistSecretToken?: string) {\n    return this._withRetry(async () => {\n      try {\n        if (!Array.isArray(ids) || ids.length === 0) {\n          throw new SCDLError(\n            'IDs muszą być niepustą tablicą liczb.',\n            SCDLErrorType.INVALID_URL\n          )\n        }\n\n        return getTrackInfoByID(await this.getClientID(), this.axios, ids, playlistID, playlistSecretToken)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania informacji o utworach po ID: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns info about the given set\n   * @param url - URL of the Soundcloud set\n   * @returns Info about the set\n   */\n  async getSetInfo(url: string) {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'getSetInfo')\n\n      try {\n        const preparedUrl = await this.prepareURL(url)\n        return getSetInfo(preparedUrl, await this.getClientID(), this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania informacji o secie: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   * Searches for tracks/playlists for the given query\n   * @param options - The search option\n   * @returns SearchResponse\n   */\n  async search(options: SearchOptions) {\n    return this._withRetry(async () => {\n      try {\n        if (!options || (!options.q && !options.query)) {\n          throw new SCDLError(\n            'Opcje wyszukiwania muszą zawierać query (q) lub query.',\n            SCDLErrorType.INVALID_URL\n          )\n        }\n\n        return search(options, this.axios, await this.getClientID())\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas wyszukiwania: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error\n        )\n      }\n    })\n  }\n\n  /**\n   * Finds related tracks to the given track specified by ID\n   * @param id - The ID of the track\n   * @param limit - The number of results to return\n   * @param offset - Used for pagination, set to 0 if you will not use this feature.\n   */\n  async related(id: number, limit: number, offset = 0) {\n    return this._withRetry(async () => {\n      try {\n        if (!Number.isInteger(id) || id <= 0) {\n          throw new SCDLError(\n            'ID musi być dodatnią liczbą całkowitą.',\n            SCDLErrorType.INVALID_URL\n          )\n        }\n\n        if (!Number.isInteger(limit) || limit <= 0) {\n          throw new SCDLError(\n            'Limit musi być dodatnią liczbą całkowitą.',\n            SCDLErrorType.INVALID_URL\n          )\n        }\n\n        return related(id, limit, offset, this.axios, await this.getClientID())\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania powiązanych utworów: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns the audio streams and titles of the tracks in the given playlist.\n   * @param url - The url of the playlist\n   */\n  async downloadPlaylist(url: string): Promise<[ReadableStream<any>[], String[]]> {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'downloadPlaylist')\n\n      try {\n        if (!this.isPlaylistURL(url)) {\n          throw new SCDLError(\n            'URL nie jest prawidłowym linkiem do playlisty SoundCloud.',\n            SCDLErrorType.INVALID_URL,\n            undefined,\n            url\n          )\n        }\n\n        const preparedUrl = await this.prepareURL(url)\n        return downloadPlaylist(preparedUrl, await this.getClientID(), this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania playlisty: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns track information for a user's likes\n   * @param options - Can either be the profile URL of the user, or their ID\n   * @returns - An array of tracks\n   */\n  async getLikes(options: GetLikesOptions): Promise<PaginatedQuery<Like>> {\n    return this._withRetry(async () => {\n      try {\n        let id: number\n        const clientID = await this.getClientID()\n\n        if (options.id) {\n          id = options.id\n        } else if (options.profileUrl) {\n          this._validateUrl(options.profileUrl, 'getLikes')\n          const user = await getUser(await this.prepareURL(options.profileUrl), clientID, this.axios)\n          id = user.id\n        } else if (options.nextHref) {\n          return await getLikes(options, clientID, this.axios)\n        } else {\n          throw new SCDLError(\n            'options.id lub options.profileURL musi być podane.',\n            SCDLErrorType.INVALID_URL\n          )\n        }\n\n        options.id = id\n        return getLikes(options, clientID, this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania polubień: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error\n        )\n      }\n    })\n  }\n\n  /**\n   * Returns information about a user\n   * @param url - The profile URL of the user\n   */\n  async getUser(url: string): Promise<User> {\n    return this._withRetry(async () => {\n      this._validateUrl(url, 'getUser')\n\n      try {\n        const preparedUrl = await this.prepareURL(url)\n        return getUser(preparedUrl, await this.getClientID(), this.axios)\n      } catch (error) {\n        if (error instanceof SCDLError) throw error\n        throw new SCDLError(\n          `Błąd podczas pobierania informacji o użytkowniku: ${getErrorMessage(error)}`,\n          SCDLErrorType.NETWORK_ERROR,\n          error as Error,\n          url\n        )\n      }\n    })\n  }\n\n  /**\n   * Sets the instance of Axios to use to make requests to SoundCloud API\n   * @param instance - An instance of Axios\n   */\n  setAxiosInstance(instance: AxiosInstance) {\n    this.axios = instance\n    this._setupAxiosInterceptors()\n  }\n\n  /**\n   * Returns whether or not the given URL is a valid Soundcloud URL\n   * @param url - URL of the Soundcloud track\n  */\n  isValidUrl(url: string) {\n    try {\n      return isValidURL(url, this.convertFirebaseLinks, this.stripMobilePrefix)\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Returns whether or not the given URL is a valid playlist SoundCloud URL\n   * @param url - The URL to check\n   */\n  isPlaylistURL(url: string) {\n    try {\n      return isPlaylistURL(url)\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the given URL is a personalized track URL. (of the form https://soundcloud.com/discover/sets/personalized-tracks::user-sdlkfjsldfljs:847104873)\n   * @param url - The URL to check\n   */\n  isPersonalizedTrackURL(url: string) {\n    try {\n      return isPersonalizedTrackURL(url)\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the given URL is a Firebase URL (of the form https://soundcloud.app.goo.gl/XXXXXXXX)\n   * @param url - The URL to check\n   */\n  isFirebaseURL(url: string) {\n    try {\n      return isFirebaseURL(url)\n    } catch (error) {\n      return false\n    }\n  }\n\n  async getClientID(): Promise<string> {\n    try {\n      if (!this._clientID) {\n        await this.setClientID()\n      }\n\n      if (!this._clientID) {\n        throw new SCDLError(\n          'Nie można pobrać Client ID.',\n          SCDLErrorType.CLIENT_ID_ERROR\n        )\n      }\n\n      return this._clientID\n    } catch (error) {\n      if (error instanceof SCDLError) throw error\n      throw new SCDLError(\n        `Błąd podczas pobierania Client ID: ${getErrorMessage(error)}`,\n        SCDLErrorType.CLIENT_ID_ERROR,\n        error as Error\n      )\n    }\n  }\n\n  /** @internal */\n  async setClientID(clientID?: string): Promise<string> {\n    try {\n      if (!clientID) {\n        if (!this._clientID) {\n          if (this.saveClientID) {\n            const filename = path.resolve(__dirname, this._filePath ? this._filePath : '../client_id.json')\n            const c = await this._getClientIDFromFile(filename)\n            if (!c) {\n              this._clientID = await sckey.fetchKey()\n              const data = {\n                clientID: this._clientID,\n                date: new Date().toISOString()\n              }\n\n              try {\n                await fs.promises.writeFile(filename, JSON.stringify(data))\n              } catch (err) {\n                console.warn('Nie można zapisać client_id do pliku: ' + err)\n              }\n            } else {\n              this._clientID = c\n            }\n          } else {\n            this._clientID = await sckey.fetchKey()\n          }\n        }\n\n        if (!this._clientID) {\n          throw new SCDLError(\n            'Nie ma ustawionego Client ID.',\n            SCDLErrorType.CLIENT_ID_ERROR\n          )\n        }\n\n        return this._clientID\n      }\n\n      this._clientID = clientID\n      return clientID\n    } catch (error) {\n      throw new SCDLError(\n        `Błąd podczas ustawiania Client ID: ${getErrorMessage(error)}`,\n        SCDLErrorType.CLIENT_ID_ERROR,\n        error as Error\n      )\n    }\n  }\n\n  /** @internal */\n  private async _getClientIDFromFile(filename: string): Promise<string> {\n    // Check if file exists\n    if (!fs.existsSync(filename)) return ''\n\n    try {\n      const data = await fs.promises.readFile(filename, 'utf8')\n\n      let parsed: ClientIDData\n      try {\n        parsed = JSON.parse(data)\n      } catch (parseErr) {\n        throw new SCDLError(\n          'Błąd parsowania client_id.json',\n          SCDLErrorType.PARSING_ERROR,\n          parseErr instanceof Error ? parseErr : undefined\n        )\n      }\n\n      // Validate required properties\n      if (!parsed.date || !parsed.clientID) {\n        throw new SCDLError(\n          \"Brakuje właściwości 'date' lub 'clientID' w client_id.json\",\n          SCDLErrorType.PARSING_ERROR\n        )\n      }\n\n      if (typeof parsed.clientID !== 'string') {\n        throw new SCDLError(\n          \"Właściwość 'clientID' nie jest stringiem w client_id.json\",\n          SCDLErrorType.PARSING_ERROR\n        )\n      }\n\n      if (typeof parsed.date !== 'string') {\n        throw new SCDLError(\n          \"Właściwość 'date' nie jest stringiem w client_id.json\",\n          SCDLErrorType.PARSING_ERROR\n        )\n      }\n\n      // Validate date\n      const cachedDate = new Date(parsed.date)\n      if (Number.isNaN(cachedDate.getTime())) {\n        throw new SCDLError(\n          \"Nieprawidłowy obiekt daty z 'date' w client_id.json\",\n          SCDLErrorType.PARSING_ERROR\n        )\n      }\n\n      // Check if cache expired (older than 24 hours)\n      if (Date.now() - cachedDate.getTime() >= CLIENT_ID_EXPIRY_MS) {\n        // Delete expired cache file\n        fs.promises.unlink(filename).catch(() => {\n          // Ignore unlink errors\n        })\n        return ''\n      }\n\n      return parsed.clientID\n    } catch (error) {\n      if (error instanceof SCDLError) throw error\n      throw new SCDLError(\n        `Błąd czytania pliku client_id.json: ${getErrorMessage(error)}`,\n        SCDLErrorType.FILE_SYSTEM_ERROR,\n        error instanceof Error ? error : undefined\n      )\n    }\n  }\n\n  /**\n   * Prepares the given URL by stripping its mobile prefix (if this.stripMobilePrefix is true)\n   * and converting it to a regular URL (if this.convertFireBaseLinks is true.)\n   * @param url\n   */\n  async prepareURL(url: string): Promise<string> {\n    try {\n      let processedUrl = url\n\n      if (this.stripMobilePrefix) {\n        processedUrl = stripMobilePrefix(processedUrl)\n      }\n\n      if (this.convertFirebaseLinks && isFirebaseURL(processedUrl)) {\n        const converted = await convertFirebaseURL(processedUrl, this.axios)\n        if (!converted) {\n          throw new SCDLError(\n            'Nie można przekonwertować Firebase URL na prawidłowy link SoundCloud.',\n            SCDLErrorType.INVALID_URL,\n            undefined,\n            processedUrl\n          )\n        }\n        processedUrl = converted\n      }\n\n      return processedUrl\n    } catch (error) {\n      if (error instanceof SCDLError) throw error\n      throw new SCDLError(\n        `Błąd podczas przygotowywania URL: ${getErrorMessage(error)}`,\n        SCDLErrorType.INVALID_URL,\n        error as Error,\n        url\n      )\n    }\n  }\n\n  /**\n   * Sprawdza czy błąd można ponowić\n   */\n  isRetryableError(error: SCDLError): boolean {\n    return ![\n      SCDLErrorType.INVALID_URL,\n      SCDLErrorType.REGION_RESTRICTED,\n      SCDLErrorType.NOT_STREAMABLE,\n      SCDLErrorType.SAMPLE_TRACK,\n      SCDLErrorType.FORMAT_NOT_FOUND\n    ].includes(error.type)\n  }\n\n  /**\n   * Czyści cache client ID (zmusza do ponownego pobrania)\n   */\n  clearClientID(): void {\n    this._clientID = undefined\n  }\n\n  /**\n   * Sprawdza status połączenia z SoundCloud API\n   */\n  async healthCheck(): Promise<{ status: 'ok' | 'error', clientID?: string, error?: string }> {\n    try {\n      const clientID = await this.getClientID()\n\n      // Prosta próba zapytania do API\n      const testUrl = 'https://soundcloud.com/mt-eden/still-alive'\n      await this.getInfo(testUrl)\n\n      return {\n        status: 'ok',\n        clientID: clientID.substring(0, 8) + '...' // Pokaż tylko początek dla bezpieczeństwa\n      }\n    } catch (error) {\n      return {\n        status: 'error',\n        error: error instanceof SCDLError ? error.message : (error as Error).message\n      }\n    }\n  }\n\n  /**\n   * Ustawia opcje retry dla instancji\n   */\n  setRetryOptions(maxRetries: number, retryDelay: number): void {\n    if (!Number.isInteger(maxRetries) || maxRetries < 0) {\n      throw new SCDLError(\n        'maxRetries musi być nieujemną liczbą całkowitą.',\n        SCDLErrorType.INVALID_URL\n      )\n    }\n\n    if (!Number.isInteger(retryDelay) || retryDelay < 0) {\n      throw new SCDLError(\n        'retryDelay musi być nieujemną liczbą całkowitą.',\n        SCDLErrorType.INVALID_URL\n      )\n    }\n\n    this._maxRetries = maxRetries\n    this._retryDelay = retryDelay\n  }\n\n  /**\n   * Pobiera obecne ustawienia retry\n   */\n  getRetryOptions(): { maxRetries: number, retryDelay: number } {\n    return {\n      maxRetries: this._maxRetries,\n      retryDelay: this._retryDelay\n    }\n  }\n\n  /**\n   * Ustawia timeout dla żądań\n   */\n  setTimeout(timeout: number): void {\n    if (!Number.isInteger(timeout) || timeout <= 0) {\n      throw new SCDLError(\n        'Timeout musi być dodatnią liczbą całkowitą.',\n        SCDLErrorType.INVALID_URL\n      )\n    }\n\n    this._timeout = timeout\n    this.axios.defaults.timeout = timeout\n  }\n\n  /**\n   * Pobiera obecny timeout\n   */\n  getTimeout(): number {\n    return this._timeout\n  }\n\n  /**\n   * Włącza/wyłącza walidację URL\n   */\n  setUrlValidation(validate: boolean): void {\n    this._validateUrls = validate\n  }\n\n  /**\n   * Sprawdza czy walidacja URL jest włączona\n   */\n  isUrlValidationEnabled(): boolean {\n    return this._validateUrls\n  }\n}\n\n// SCDL instance with default configuration\nconst scdl = new SCDL()\n\n// Creates an instance of SCDL with custom configuration\nconst create = (options: SCDLOptions): SCDL => new SCDL(options)\n\nexport { create }\n\nscdl.STREAMING_PROTOCOLS = _PROTOCOLS\nscdl.FORMATS = _FORMATS\n\nexport default scdl;\n"],"mappings":"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"}